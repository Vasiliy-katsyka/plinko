<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Плинко</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0f1a; --surface-color: #1a1e3a; --surface-color-2: #252a4a;
            --border-color: rgba(255, 255, 255, 0.1); --text-color: #e2e8f0; --text-muted: #8a99b5;
            --button-primary-bg: linear-gradient(45deg, #a855f7, #6d28d9); --button-primary-text-color: #ffffff;
            --peg-color: #a3b8d9; --chip-color: #00f5ff; --highlight-primary: #a855f7; --highlight-secondary: #00f5ff;
            --button-secondary-bg: linear-gradient(45deg, #ec4899, #d946ef); --stepper-bg: #2c336b;
            --slot-high: #8e44ad; --slot-mid: #5a57c4; --slot-low: #3d4a99; --slot-zero: #2c336b; --nav-height: 70px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html { height: 100%; }
        body {
            font-family: 'Poppins', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; min-height: 100%;
            padding: 33px 15px calc(var(--nav-height) + 30px);
            overflow-y: auto;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        #app-container { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 15px; }
        .view { display: none; flex-direction: column; align-items: center; width: 100%; gap: 15px; }
        .view.active { display: flex; }
        header { width: 100%; text-align: center; margin-bottom: 5px; }
        header h1 {
            font-size: clamp(1.8rem, 7vw, 2.5rem); font-weight: 700; text-transform: uppercase; letter-spacing: 2px;
            color: white; background: linear-gradient(90deg, var(--highlight-secondary), var(--highlight-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(168, 85, 247, 0.3); margin: 0;
        }
        .game-board-area { width: 100%; }
        #plinko-board-container { position: relative; width: 100%; flex-shrink: 0; }
        #plinko-board {
            width: 100%; aspect-ratio: 1 / 1;
            background: radial-gradient(circle, var(--surface-color-2) 0%, var(--surface-color) 100%);
            border-radius: 20px 20px 0 0; position: relative;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.5); border: 1px solid var(--border-color);
            border-bottom: none; overflow: hidden;
        }
        .peg { width: 8px; height: 8px; background-color: var(--peg-color); border-radius: 50%; position: absolute; box-shadow: 0 0 5px rgba(163, 184, 217, 0.3); transform: translate(-50%, -50%); }
        .chip { position: absolute; background-color: var(--chip-color); border-radius: 50%; filter: drop-shadow(0 0 8px var(--chip-color)) drop-shadow(0 0 15px var(--chip-color)); visibility: hidden; transform: translate(-50%, -50%); transition: width 0.3s, height 0.3s; }
        #slots-container { display: flex; width: 100%; border-radius: 0 0 20px 20px; overflow: hidden; border: 1px solid var(--border-color); border-top: none; }
        .slot { flex-grow: 1; height: 45px; display: flex; justify-content: center; align-items: center; font-weight: 600; font-size: clamp(0.6rem, 2.5vw, 0.8rem); color: white; transition: all 0.3s ease; }
        @keyframes highlight-win { 0% { transform: scale(1); } 50% { transform: scale(1.1); filter: brightness(2) drop-shadow(0 0 15px var(--highlight-secondary)); } 100% { transform: scale(1); } }
        .slot.highlight { animation: highlight-win 0.6s ease-out; z-index: 10; }
        .panel { background-color: var(--surface-color); padding: 12px; border-radius: 20px; width: 100%; display: flex; flex-direction: column; gap: 10px; border: 1px solid var(--border-color); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        .balance-display { display: flex; justify-content: space-between; align-items: center; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 8px 15px; }
        .balance-display label { font-size: 0.9rem; color: var(--text-muted); font-weight: 500; }
        .balance-display .value { background: none; border: none; outline: none; color: var(--text-color); font-size: 1.1rem; font-weight: 600; text-align: right; }
        .collapsible-header { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 12px 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; font-weight: 600; user-select: none; }
        .collapsible-header .setting-value { color: var(--text-color); } .collapsible-header .setting-label { color: var(--text-muted); }
        .toggle-icon { transition: transform 0.3s ease; } .toggle-icon.open { transform: rotate(180deg); }
        .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.35s ease-out; display: flex; flex-direction: column; gap: 8px; }
        .collapsible-content.open { max-height: 300px; margin-top: 5px; }
        .stepper-input-group, .risk-selector { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 12px; display: flex; align-items: center; padding: 4px; height: 48px; }
        .stepper-input-group { padding-left: 15px; } .stepper-input-group label { font-size: 0.9rem; color: var(--text-muted); margin-right: auto;}
        .stepper-input-group input { background: transparent; border: none; color: var(--text-color); font-weight: 600; font-size: 1rem; text-align: center; width: 60px; -moz-appearance: textfield; }
        .stepper-input-group input::-webkit-inner-spin-button, .stepper-input-group input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        .stepper-button { background: var(--stepper-bg); border: none; color: var(--text-color); width: 32px; height: 32px; border-radius: 8px; font-size: 1.4rem; line-height: 1; cursor: pointer; transition: background 0.2s; margin: 0 4px; }
        .risk-selector { padding: 3px; height: 48px; }
        .risk-button { flex-grow: 1; padding: 8px 5px; border: none; background: none; border-radius: 9px; color: var(--text-muted); font-family: 'Poppins', sans-serif; font-weight: 600; font-size: 0.9rem; cursor: pointer; transition: all 0.3s ease; }
        .risk-button.active { background-color: var(--highlight-primary); color: white; }
        .main-button { width: 100%; padding: 18px 15px; font-weight: 700; font-size: 1.2rem; cursor: pointer; border: none; border-radius: 12px; color: var(--button-primary-text-color); text-shadow: 0 1px 3px rgba(0,0,0,0.3); box-shadow: 0 5px 15px rgba(0,0,0,0.2); transition: all 0.2s ease; display: flex; justify-content: center; align-items: center; background: var(--button-primary-bg); }
        #auto-drop-button {
            width: auto; /* Override width: 100% */
            flex-grow: 1; /* Allow it to take up available space */
            flex-shrink: 0; /* Prevent it from shrinking */
            padding: 0 15px; /* Reduce horizontal padding */
            font-size: 0.9rem; /* Smaller font */
            margin-left: 10px; /* Add space between it and the input */
            height: 40px; /* Match the stepper buttons' height */
            border-radius: 8px;
        }
        .main-button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); filter: brightness(1.1); }
        .main-button:active:not(:disabled) { transform: translateY(-1px); }
        .main-button:disabled { background: #4a5568 !important; cursor: not-allowed; transform: none; box-shadow: none; filter: none; }
        #bottom-nav { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 500px; height: var(--nav-height); background-color: var(--surface-color); display: flex; justify-content: space-around; align-items: center; box-shadow: 0 -5px 30px rgba(0,0,0,0.3); border-top: 1px solid var(--border-color); z-index: 100; }
        .nav-button { background: none; border: none; color: var(--text-muted); font-family: 'Poppins', sans-serif; font-size: 0.7rem; font-weight: 600; cursor: pointer; padding: 10px; display: flex; flex-direction: column; align-items: center; gap: 4px; opacity: 0.7; transition: all 0.3s ease; position: relative; }
        .nav-button.active { color: var(--highlight-primary); opacity: 1; transform: translateY(-3px); }
        .nav-button.active::after { content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); width: 6px; height: 6px; border-radius: 50%; background-color: var(--highlight-primary); }
        .nav-button svg { width: 24px; height: 24px; fill: currentColor; }
        .info-text { text-align: center; color: var(--text-muted); margin-bottom: 20px; line-height: 1.6; }
        #profile-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            border: 3px solid var(--highlight-primary);
            margin: 0 auto 15px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: 700;
            object-fit: cover;
            background-color: var(--surface-color-2);
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.4);
            overflow: hidden; /* <-- ADD THIS LINE */
        }
        #profile-name { text-align: center; font-size: 1.8rem; font-weight: 700; }
        #profile-username { text-align: center; color: var(--text-muted); font-size: 1rem; margin-bottom: 25px; }
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(10,10,20,0.7); backdrop-filter: blur(8px); align-items: center; justify-content: center; }
        .modal-content { background-color: var(--surface-color); padding: 20px; border-radius: 16px; width: 90%; max-width: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); border: 1px solid var(--border-color); }
        .modal-content h3 { margin-top: 0; }
        .modal-body { margin: 15px 0; } .modal-actions { display: flex; gap: 10px; } .modal-actions .button { flex-grow: 1; }
        #deposit-ton-modal input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); margin-bottom: 10px; text-align: center; }
        .loader { border: 4px solid var(--surface-hover-color); border-top: 4px solid var(--primary-color); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 15px auto; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #deposit-amount-input { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); text-align: center; font-size: 1.1rem; }
    </style>
</head>
<body>
    <div id="app-container">
        <!-- Mai Game View -->
        <div id="main-game-view" class="view active">
            <header><h1>Plinko</h1></header>
            <div class="game-board-area">
                <div id="plinko-board-container"><div id="plinko-board"></div></div>
                <div id="slots-container"></div>
            </div>
            <div class="panel">
                <div class="balance-display"><label>Баланс</label><div id="balance" class="value">0.00 TON</div></div>
                <div id="settings-panel">
                    <div class="collapsible-header" id="collapsible-header">
                        <div><span class="setting-label">Ставка: </span><span class="setting-value" id="header-bet-value">0.01</span><span class="setting-label" style="margin-left: 15px;">Риск: </span><span class="setting-value" id="header-risk-value">Средний</span></div>
                        <svg class="toggle-icon" id="toggle-icon" width="24" height="24" viewBox="0 0 24 24"><path d="M7 10L12 15L17 10" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                    </div>
                    <div class="collapsible-content" id="collapsible-content">
                        <div class="stepper-input-group"><label>Ставка (TON)</label><button class="stepper-button" data-action="minus" data-target="bet-amount">-</button><input type="number" id="bet-amount" value="0.01" min="0.01" step="0.01"><button class="stepper-button" data-action="plus" data-target="bet-amount">+</button></div>
                        <div class="stepper-input-group"><label>Авто</label><button class="stepper-button" data-action="minus" data-target="auto-drop-count">-</button><input type="number" id="auto-drop-count" value="10" min="1" max="100"><button class="stepper-button" data-action="plus" data-target="auto-drop-count">+</button><button id="auto-drop-button" class="main-button">Старт</button></div>
                        <div class="risk-selector"><button class="risk-button" data-risk="low">Низкий</button><button class="risk-button active" data-risk="medium">Средний</button><button class="risk-button" data-risk="high">Высокий</button></div>
                    </div>
                </div>
                <button id="drop-button" class="main-button">Бросить</button>
            </div>
        </div>
        <!-- Free Try View -->
        <div id="free-try-view" class="view">
            <header><h1>Free Try</h1></header>
            <div class="panel">
                <p class="info-text">Получайте бесплатный бросок (ставка 0.01 TON) каждые 24 часа!</p>
                <div id="timer-container" style="text-align:center; margin: 20px 0;">
                    <h2 id="timer" style="font-size: 2.5rem; color: var(--highlight-secondary); margin-bottom: 5px;">00:00:00</h2>
                    <span style="color: var(--text-muted);">До следующего броска</span>
                </div>
                <button id="claim-free-drop-btn" class="main-button">Забрать бросок</button>
            </div>
        </div>
        <!-- Profile View -->
        <div id="profile-view" class="view">
            <header><h1>Профиль</h1></header>
            <div class="panel">
                <div id="profile-avatar">?</div>
                <h2 id="profile-name">Пользователь</h2><p id="profile-username">@username</p>
                <div class="balance-display"><label>Баланс</label><div id="profile-balance" class="value">0.00 TON</div></div>
                <h3 style="text-align:center; margin:15px 0 10px; font-size:1.1rem; color:var(--text-muted);">Пополнить баланс</h3>
                <div style="display:flex; gap:10px; flex-direction: column;">
                    <input type="number" id="deposit-amount-input" placeholder="Сумма (TON или Stars)" >
                    <button id="topup-ton-btn" class="main-button">💎 TON</button>
                    <button id="topup-stars-btn" class="main-button" style="background: var(--button-secondary-bg);">⭐ Stars</button>
                    <button id="topup-gifts-btn" class="main-button" style="background: var(--surface-color-2);">🎁 Подарками</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Bottom Navigation -->
    <nav id="bottom-nav">
        <button class="nav-button" data-view="free-try-view"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,6H18.18C18.09,5.69 18,5.35 18,5A3,3 0 0,0 15,2C13.95,2 13.04,2.54 12.5,3.35C11.96,2.54 11.05,2 10,2A3,3 0 0,0 7,5C7,5.35 7.09,5.69 7.18,6H4A2,2 0 0,0 2,8V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V8A2,2 0 0,0 20,6M15,4A1,1 0 0,1 16,5A1,1 0 0,1 15,6A1,1 0 0,1 14,5A1,1 0 0,1 15,4M10,4A1,1 0 0,1 11,5A1,1 0 0,1 10,6A1,1 0 0,1 9,5A1,1 0 0,1 10,4M20,19H4V8H20V19Z" fill="currentColor"/></svg><span>Free Try</span></button>
        <button class="nav-button active" data-view="main-game-view"><svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg><span>Игра</span></button>
        <button class="nav-button" data-view="profile-view"><svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg><span>Профиль</span></button>
    </nav>

    <!-- Modals -->
    <div id="deposit-ton-modal" class="modal">
        <div class="modal-content">
            <h3>Депозит TON</h3>
            <div class="modal-body" style="text-align: center;">
                <p>Нажмите "Открыть кошелек", чтобы создать транзакцию. Сумма будет взята из поля на экране профиля.</p>
                
                <div style="margin: 15px 0;">
                    <strong style="color: var(--text-muted);">ВАШ УНИКАЛЬНЫЙ КОММЕНТАРИЙ:</strong><br>
                    <input type="text" id="ton-deposit-comment" readonly style="background-color: var(--bg-color); border-color: #ff9800; text-align: center; font-weight: bold; margin-top: 5px;">
                    <p style="color: #ff9800; font-size: 0.8rem; margin-top: 5px;"><strong>НЕ ИЗМЕНЯЙТЕ ЭТОТ КОММЕНТАРИЙ В КОШЕЛЬКЕ!</strong></p>
                </div>
                
                <div id="ton-deposit-loader" class="loader" style="display:none;"></div>
                <p id="ton-deposit-status"></p>
            </div>
            <div class="modal-actions" style="flex-direction: column; gap: 12px;">
                <!-- This is the new primary button -->
                <button id="open-wallet-btn" class="main-button">Открыть кошелек</button>
                <button id="verify-ton-deposit-btn" class="main-button" style="background: var(--surface-color-2);">Я уже оплатил (Проверить)</button>
                <button id="close-ton-deposit-modal-btn" class="main-button" style="background: var(--stepper-bg);">Отмена</button>
            </div>
        </div>
    </div>
    <div id="deposit-gifts-modal" class="modal">
        <div class="modal-content">
            <h3>Депозит Подарками</h3>
            <div class="modal-body" style="text-align: center;">
                <p>Для пополнения подарками переведите ваш подарок @uberstard, в короткий период он вручную зачислит вам TON на баланс.</p>
            </div>
            <div class="modal-actions" style="flex-direction: column;">
                <a href="https://t.me/uberstard" target="_blank" class="main-button" style="text-decoration: none;">Связаться с @uberstard</a>
                <button id="close-gifts-modal-btn" class="main-button" style="background: var(--stepper-bg);">Закрыть</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const tg = window.Telegram.WebApp;
    const API_BASE_URL = 'https://plinko-4vm7.onrender.com';
    const FREE_DROP_INTERVAL = 10 * 1000;
    const FREE_DROP_BET = 0.01;

    let currentUser = { id: null, balance: 0.00, last_free_drop_claim: null };
    let currentRisk = 'medium';
    let isDropping = false;
    let autoDropInterval = null;
    let activeChips = [];
    let chipIdCounter = 0;
    let pegs = [];
    let BOARD_WIDTH, BOARD_HEIGHT, CHIP_RADIUS, PEG_RADIUS;
    let GRAVITY = 0.25, DAMPING = 0.55;
    let freeDropTimerInterval = null;
    let isAutoDropping = false;
    let autoDropCount = 0;
    let autoDropIntervalId = null;
    let currentDepositInfo = { address: '', comment: '' };
    
    const riskLevelConfigs = {
        low: {
            rows: 8,
            cols: 10, // Visual setting for peg spacing
            multipliers: [4, 2, 1.2, 0.9, 0.7, 0.9, 1.2, 2, 4],
            name: "Низкий"
        },
        medium: {
            rows: 12,
            cols: 14, // Visual setting for peg spacing
            multipliers: [18, 5, 2, 1.1, 0.8, 0.5, 0.3, 0.5, 0.8, 1.1, 2, 5, 18],
            name: "Средний"
        },
        high: {
            rows: 16,
            cols: 18, // Visual setting for peg spacing
            multipliers: [130, 25, 8, 2, 0.5, 0.2, 0.1, 0.1, 0, 0.1, 0.1, 0.2, 0.5, 2, 8, 25, 130],
            name: "Высокий"
        }
    };
    
    const selectors = {
        views: document.querySelectorAll('.view'), navButtons: document.querySelectorAll('.nav-button'),
        balance: document.getElementById('balance'), profileBalance: document.getElementById('profile-balance'),
        profileName: document.getElementById('profile-name'), profileUsername: document.getElementById('profile-username'),
        profileAvatar: document.getElementById('profile-avatar'), board: document.getElementById('plinko-board'),
        slotsContainer: document.getElementById('slots-container'), dropButton: document.getElementById('drop-button'),
        betAmountInput: document.getElementById('bet-amount'), riskButtons: document.querySelectorAll('.risk-button'),
        autoDropButton: document.getElementById('auto-drop-button'), autoDropCountInput: document.getElementById('auto-drop-count'),
        collapsibleHeader: document.getElementById('collapsible-header'), collapsibleContent: document.getElementById('collapsible-content'),
        toggleIcon: document.getElementById('toggle-icon'), headerBetValue: document.getElementById('header-bet-value'),
        headerRiskValue: document.getElementById('header-risk-value'), stepperButtons: document.querySelectorAll('.stepper-button'),
        topUpTonBtn: document.getElementById('topup-ton-btn'), topUpStarsBtn: document.getElementById('topup-stars-btn'),
        topUpGiftsBtn: document.getElementById('topup-gifts-btn'), depositAmountInput: document.getElementById('deposit-amount-input'),
        depositTonModal: document.getElementById('deposit-ton-modal'), tonDepositAddress: document.getElementById('ton-deposit-address'),
        tonDepositComment: document.getElementById('ton-deposit-comment'), verifyTonDepositBtn: document.getElementById('verify-ton-deposit-btn'),
        closeTonDepositModalBtn: document.getElementById('close-ton-deposit-modal-btn'), tonDepositLoader: document.getElementById('ton-deposit-loader'),
        tonDepositStatus: document.getElementById('ton-deposit-status'), depositGiftsModal: document.getElementById('deposit-gifts-modal'),
        closeGiftsModalBtn: document.getElementById('close-gifts-modal-btn'),
        timerElement: document.getElementById('timer'), claimFreeDropBtn: document.getElementById('claim-free-drop-btn'),
    };
    selectors.autoDropButton.addEventListener('click', handleAutoDrop);
    
    async function apiRequest(endpoint, method = 'POST', body = {}) {
        const config = { method, headers: { 'Content-Type': 'application/json', 'X-Telegram-Init-Data': tg.initData } };
        if (method.toUpperCase() !== 'GET') { config.body = JSON.stringify(body); }
        try {
            const response = await fetch(API_BASE_URL + endpoint, config);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error ${response.status}`);
            }
            return response.json();
        } catch (error) { tg.showAlert(error.message); throw error; }
    }

    async function initializeApp() {
        tg.ready(); tg.expand();
        try {
            const userData = await apiRequest('/api/user_data', 'POST', {});
            currentUser = userData;
            updateBalanceUI();
            updateProfileUI();
        } catch (error) {
            console.error("Failed to load user data:", error);
            tg.showAlert("Не удалось загрузить данные пользователя. Попробуйте перезапустить приложение.");
            return; // Stop execution if user data fails
        }
        setupBoard(currentRisk);
        updateHeaderValues();
    }

    function updateBalanceUI() {
        const formattedBalance = `${currentUser.balance.toFixed(4)} TON`;
        selectors.balance.textContent = formattedBalance;
        selectors.profileBalance.textContent = formattedBalance;
        selectors.betAmountInput.max = currentUser.balance;
    }


    function updateProfileUI() {
        selectors.profileName.textContent = currentUser.first_name || "User";
        selectors.profileUsername.textContent = currentUser.username ? `@${currentUser.username}` : `#${currentUser.id}`;
        
        // --- START: MODIFIED AVATAR LOGIC ---
        selectors.profileAvatar.innerHTML = ''; // Clear previous content (initials)
        if (currentUser.photo_url) {
            const img = document.createElement('img');
            img.src = currentUser.photo_url;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            selectors.profileAvatar.appendChild(img);
            selectors.profileAvatar.style.padding = '0'; // Remove padding if image exists
            selectors.profileAvatar.style.fontSize = '0'; // Hide any text fallback
        } else {
            selectors.profileAvatar.textContent = (currentUser.first_name || "?").charAt(0);
            selectors.profileAvatar.style.padding = ''; // Reset padding
            selectors.profileAvatar.style.fontSize = '3rem'; // Reset font size
        }
        // --- END: MODIFIED AVATAR LOGIC ---
    }
    function switchView(viewId) {
        if (freeDropTimerInterval) { clearInterval(freeDropTimerInterval); freeDropTimerInterval = null; }
        selectors.views.forEach(v => v.classList.toggle('active', v.id === viewId));
        selectors.navButtons.forEach(b => b.classList.toggle('active', b.dataset.view === viewId));
        if (viewId === 'free-try-view') { initFreeTryView(); }
    }
    function updateHeaderValues() {
        selectors.headerBetValue.textContent = `${parseFloat(selectors.betAmountInput.value).toFixed(2)}`;
        selectors.headerRiskValue.textContent = riskLevelConfigs[currentRisk].name;
    }
    function handleAutoDrop() {
        if (isAutoDropping) {
            // --- STOP AUTO DROP ---
            clearInterval(autoDropIntervalId);
            isAutoDropping = false;
            selectors.autoDropButton.textContent = 'Старт';
            selectors.autoDropButton.style.background = 'var(--button-secondary-bg)';
            setControlsDisabled(false); // Re-enable all controls
        } else {
            // --- START AUTO DROP ---
            const totalDrops = parseInt(selectors.autoDropCountInput.value, 10);
            if (isNaN(totalDrops) || totalDrops < 1) {
                tg.showAlert('Пожалуйста, введите корректное количество бросков.');
                return;
            }
            
            const bet = parseFloat(selectors.betAmountInput.value);
            if (bet * totalDrops > currentUser.balance) {
                tg.showAlert('Недостаточно средств для указанного количества авто-бросков.');
                return;
            }
    
            isAutoDropping = true;
            autoDropCount = 0;
            selectors.autoDropButton.textContent = 'Стоп';
            selectors.autoDropButton.style.background = '#e53e3e'; // Red color for stop
            setControlsDisabled(true); // Disable controls
            selectors.autoDropButton.disabled = false; // But keep the stop button enabled
    
            autoDropIntervalId = setInterval(() => {
                if (autoDropCount >= totalDrops || currentUser.balance < bet) {
                    handleAutoDrop(); // Stop if count is reached or balance is insufficient
                    if(currentUser.balance < bet) tg.showAlert('Авто-броски остановлены: недостаточно средств.');
                    return;
                }
                performDrop(false);
                autoDropCount++;
            }, 1000); // 1 drop per second
        }
    }
    function updateFreeDropTimer() {
        const lastClaim = currentUser.last_free_drop_claim;
        if (!lastClaim) { selectors.timerElement.textContent = "Готово!"; selectors.claimFreeDropBtn.disabled = false; return; }
        const nextAvailableTime = new Date(lastClaim).getTime() + FREE_DROP_INTERVAL;
        const timeLeft = nextAvailableTime - Date.now();
        if (timeLeft <= 0) {
            selectors.timerElement.textContent = "Готово!";
            selectors.claimFreeDropBtn.disabled = false;
            if (freeDropTimerInterval) clearInterval(freeDropTimerInterval);
        } else {
            selectors.claimFreeDropBtn.disabled = true;
            const h = Math.floor(timeLeft/36e5), m = Math.floor((timeLeft%36e5)/6e4), s = Math.floor((timeLeft%6e4)/1e3);
            selectors.timerElement.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
    }
    function copyToClipboard(element, fieldName) {
        if (!navigator.clipboard) {
            tg.showAlert('Ваш браузер не поддерживает копирование.');
            return;
        }
        navigator.clipboard.writeText(element.value).then(() => {
            tg.HapticFeedback.notificationOccurred('success');
            tg.showAlert(`${fieldName} скопирован в буфер обмена!`);
        }).catch(err => {
            tg.showAlert(`Не удалось скопировать: ${err}`);
        });
    }
    function initFreeTryView() { updateFreeDropTimer(); freeDropTimerInterval = setInterval(updateFreeDropTimer, 1000); }
    // In your HTML <script> tag
    
    async function handleClaimFreeDrop() {
        selectors.claimFreeDropBtn.disabled = true;
        try {
            const result = await apiRequest('/api/claim_free_drop', 'POST', {});
            if (result.status === 'success') {
                currentUser.last_free_drop_claim = result.new_claim_time;
                tg.showAlert(result.message);
                updateFreeDropTimer();
                switchView('main-game-view');
    
                // --- START: NEW LOGIC ---
                // Animate the result we got directly from the claim API
                const gameResult = result.game_result;
                const chipId = chipIdCounter++;
                const chipEl = document.createElement('div');
                chipEl.className = 'chip';
                chipEl.style.width = `${CHIP_RADIUS * 2}px`;
                chipEl.style.height = `${CHIP_RADIUS * 2}px`;
    
                // We pass the server result directly to the new chip
                const newChip = { 
                    id: chipId, 
                    x: BOARD_WIDTH / 2, y: CHIP_RADIUS * 2, 
                    vx: (Math.random() - 0.5) * 2, vy: 0, 
                    element: chipEl, 
                    serverResult: gameResult // Use the result from the API
                };
    
                chipEl.style.left = `${newChip.x}px`;
                chipEl.style.top = `${newChip.y}px`;
                chipEl.style.visibility = 'visible';
                selectors.board.appendChild(chipEl);
                activeChips.push(newChip);
    
                if (!isDropping) {
                    isDropping = true;
                    document.querySelectorAll('.slot.highlight').forEach(s => s.classList.remove('highlight'));
                    requestAnimationFrame(updatePhysics);
                }
                // --- END: NEW LOGIC ---
    
            } else {
                tg.showAlert(result.message);
                selectors.claimFreeDropBtn.disabled = false;
            }
        } catch (e) {
            selectors.claimFreeDropBtn.disabled = false;
        }
    }

    function getSlotColor(m) {
        if (m >= 20) return 'var(--slot-high)';
        if (m >= 1) return 'var(--slot-mid)';
        if (m > 0) return 'var(--slot-low)';
        return 'var(--slot-zero)';
    }
    function setupBoard(risk) {
        if (isDropping) return; currentRisk = risk; updateHeaderValues();
        BOARD_WIDTH = selectors.board.clientWidth; if (BOARD_WIDTH === 0) { setTimeout(() => setupBoard(risk), 50); return; }
        BOARD_HEIGHT = selectors.board.clientHeight; PEG_RADIUS = BOARD_WIDTH / 150;
        CHIP_RADIUS = (risk === 'high') ? BOARD_WIDTH / 55 : BOARD_WIDTH / 45;
        const config = riskLevelConfigs[risk]; pegs = []; selectors.board.innerHTML = ''; selectors.slotsContainer.innerHTML = '';
        const hSpacing = BOARD_WIDTH / config.cols, vSpacing = BOARD_HEIGHT / (config.rows + 1);
        for (let r = 0; r < config.rows; r++) {
            const numPegs = r % 2 === 0 ? config.cols - 1 : config.cols; const xOffset = r % 2 === 0 ? hSpacing : hSpacing / 2;
            for (let c = 0; c < numPegs; c++) {
                const x = xOffset + c * hSpacing, y = vSpacing + r * vSpacing; pegs.push({ x, y });
                const pegEl = document.createElement('div'); pegEl.className = 'peg'; pegEl.style.cssText = `width:${PEG_RADIUS * 2}px;height:${PEG_RADIUS * 2}px;left:${x}px;top:${y}px;`; selectors.board.appendChild(pegEl);
            }
        }
        config.multipliers.forEach(m => { const slot = document.createElement('div'); slot.className = 'slot'; slot.dataset.multiplier = m; slot.textContent = `${m}x`; slot.style.backgroundColor = getSlotColor(m); selectors.slotsContainer.appendChild(slot); });
        selectors.riskButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.risk === risk));
    }
    async function performDrop(isFree = false) {
        const bet = isFree ? FREE_DROP_BET : parseFloat(selectors.betAmountInput.value);
        if (!isFree && bet > currentUser.balance) {
            tg.showAlert("Недостаточно средств!");
            return;
        }
        setControlsDisabled(true);
    
        try {
            // We no longer need the 'path' from the server, just the final result
            const result = await apiRequest('/api/plinko_drop', 'POST', { bet, risk: currentRisk });
    
            if (!isFree) {
                currentUser.balance -= bet;
            }
            updateBalanceUI();
    
            const chipId = chipIdCounter++;
            const chipEl = document.createElement('div');
            chipEl.className = 'chip';
            // Use transform for positioning for smoother animation
            chipEl.style.width = `${CHIP_RADIUS * 2}px`;
            chipEl.style.height = `${CHIP_RADIUS * 2}px`;
    
            const newChip = {
                id: chipId,
                // <<< FIX: Start exactly at the top center
                x: BOARD_WIDTH / 2,
                y: CHIP_RADIUS, // Start at the very top edge
                vx: (Math.random() - 0.5) * 2, // Initial horizontal velocity for a random start
                vy: 0,
                element: chipEl,
                serverResult: result,
                isGuided: false, // <<< NEW: Flag to control the hybrid logic
                targetX: undefined
            };
            
            // Use translate for positioning - it's better for performance
            chipEl.style.transform = `translate(${newChip.x - CHIP_RADIUS}px, ${newChip.y - CHIP_RADIUS}px)`;
            chipEl.style.visibility = 'visible';
            selectors.board.appendChild(chipEl);
            
            activeChips.push(newChip); // Add the new chip to our animation list
    
            // Start the physics loop if it's not already running
            if (!isDropping) {
                isDropping = true;
                document.querySelectorAll('.slot.highlight').forEach(s => s.classList.remove('highlight'));
                requestAnimationFrame(updatePhysics);
            }
    
        } catch (error) {
            setControlsDisabled(false);
        }
    }

    function updatePhysics() {
        // Stop the animation loop if there are no more chips on the board
        if (activeChips.length === 0) {
            isDropping = false;
            setControlsDisabled(false); // Re-enable controls only when all chips are gone
            return;
        }
    
        // Loop through all active chips (backwards, as we might remove them)
        for (let i = activeChips.length - 1; i >= 0; i--) {
            const chip = activeChips[i];
    
            // <<< HYBRID LOGIC START >>>
            // Check if the chip is in the lower part of the board and hasn't been guided yet
            const takeoverHeight = BOARD_HEIGHT * 0.75; 
            if (chip.y > takeoverHeight && !chip.isGuided) {
                // --- This is the TAKEOVER point ---
                chip.isGuided = true; // Mark the chip as guided so this only runs once
    
                // Get the final slot index from the server's result
                const finalSlotIndex = chip.serverResult.final_slot_index;
                const targetSlot = document.querySelectorAll('.slot')[finalSlotIndex];
                
                if (targetSlot) {
                    // Calculate the exact center X coordinate of the target slot
                    const slotRect = targetSlot.getBoundingClientRect();
                    const boardRect = selectors.board.getBoundingClientRect();
                    const targetX = (slotRect.left - boardRect.left) + (slotRect.width / 2);
                    chip.targetX = targetX; // Store the target X on the chip object
                }
            }
            // <<< HYBRID LOGIC END >>>
    
            // Apply physics
            if (chip.isGuided && chip.targetX !== undefined) {
                // --- GUIDED MOVEMENT ---
                // If guided, we override the horizontal velocity to smoothly move to the target
                const steerForce = (chip.targetX - chip.x) * 0.1; // The 0.1 controls how strongly it steers
                chip.vx = steerForce;
                chip.vy += GRAVITY; // Gravity still applies for a natural fall
            } else {
                // --- NORMAL PHYSICS MOVEMENT ---
                chip.vy += GRAVITY; // Apply gravity
            }
    
            // Update position
            chip.x += chip.vx;
            chip.y += chip.vy;
            
            // Wall collisions
            if (chip.x - CHIP_RADIUS < 0 || chip.x + CHIP_RADIUS > BOARD_WIDTH) {
                chip.vx *= -DAMPING;
                chip.x = Math.max(CHIP_RADIUS, Math.min(chip.x, BOARD_WIDTH - CHIP_RADIUS));
            }
    
            // Peg collisions (ONLY if not in the final guided fall)
            if (!chip.isGuided) {
                pegs.forEach(peg => {
                    const dx = chip.x - peg.x;
                    const dy = chip.y - peg.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < CHIP_RADIUS + PEG_RADIUS) {
                        const angle = Math.atan2(dy, dx);
                        const overlap = (CHIP_RADIUS + PEG_RADIUS) - dist;
                        chip.x += Math.cos(angle) * overlap;
                        chip.y += Math.sin(angle) * overlap;
                        const normalX = dx / dist;
                        const normalY = dy / dist;
                        const dot = chip.vx * normalX + chip.vy * normalY;
                        chip.vx = (chip.vx - 2 * dot * normalX) * DAMPING;
                        chip.vy = (chip.vy - 2 * dot * normalY) * DAMPING;
                        chip.vx += (Math.random() - 0.5) * 0.25; // Add a tiny bit of random spin
                    }
                });
            }
            
            // Update the element's position on screen
            chip.element.style.transform = `translate(${chip.x - CHIP_RADIUS}px, ${chip.y - CHIP_RADIUS}px)`;
    
    
            // Check if chip has fallen into a slot
            if (chip.y - CHIP_RADIUS > BOARD_HEIGHT) {
                endDrop(chip);
                activeChips.splice(i, 1); // Remove chip from the active list
            }
        }
    
        // Continue the animation loop
        requestAnimationFrame(updatePhysics);
    }
    function endDrop(chip) {
        // This function is now just for cleanup and UI updates after a chip is removed
        chip.element.remove();
        const result = chip.serverResult;
        currentUser.balance = result.new_balance;
        updateBalanceUI();
    
        const targetSlot = document.querySelectorAll('.slot')[result.final_slot_index];
        if (targetSlot) {
            targetSlot.classList.add('highlight');
        }
        if (result.multiplier >= 10) {
            tg.HapticFeedback.notificationOccurred('success');
        } else if (result.multiplier >= 1) {
            tg.HapticFeedback.impactOccurred('medium');
        }
    }
    
    function setControlsDisabled(disabled) {
        selectors.dropButton.disabled = disabled;
        selectors.riskButtons.forEach(b => b.disabled = disabled);
        selectors.stepperButtons.forEach(b => b.disabled = disabled);
        selectors.betAmountInput.disabled = disabled;
        selectors.autoDropCountInput.disabled = disabled;
        selectors.collapsibleHeader.style.pointerEvents = disabled ? 'none' : 'auto';
        selectors.collapsibleHeader.style.opacity = disabled ? '0.7' : '1';
        if (!disabled) { selectors.autoDropButton.disabled = false; }
    }
    function handleBetChange() {
        let b = parseFloat(selectors.betAmountInput.value);
        if (isNaN(b) || b < 0.01) b = 0.01;
        if (b > currentUser.balance) b = currentUser.balance;
        selectors.betAmountInput.value = b.toFixed(2);
        updateHeaderValues();
    }
    function handleStepper(event) {
        const btn = event.currentTarget, action = btn.dataset.action, targetId = btn.dataset.target, input = document.getElementById(targetId);
        if (!input) return;
        if (targetId === 'bet-amount') {
            let val = parseFloat(input.value) || 0;
            let step = 0.01;
            if (val >= 1) step = 0.1; if (val >= 10) step = 1;
            if (action === 'plus') val += step; else if (action === 'minus') val -= step;
            val = Math.max(parseFloat(input.min), val);
            input.value = val.toFixed(2);
            handleBetChange();
        } else {
            let val = parseInt(input.value, 10) || 0;
            if (action === 'plus') val++; else if (action === 'minus') val--;
            val = Math.max(parseInt(input.min, 10), Math.min(parseInt(input.max, 10), val));
            input.value = val;
        }
    }
    async function handleTopUpTON() {
        // Check if an amount is entered on the profile screen
        const amountStr = selectors.depositAmountInput.value;
        if (amountStr && (isNaN(parseFloat(amountStr)) || parseFloat(amountStr) <= 0)) {
            tg.showAlert("Пожалуйста, введите корректную сумму для пополнения или оставьте поле пустым.");
            return;
        }
    
        selectors.topUpTonBtn.disabled = true;
        selectors.tonDepositStatus.textContent = "Создание запроса...";
        selectors.tonDepositLoader.style.display = 'block';
        selectors.depositTonModal.style.display = 'flex';
    
        try {
            const res = await apiRequest('/api/initiate_ton_deposit', 'POST', {});
            // Store the address and comment for later use
            currentDepositInfo = {
                address: res.recipient_address,
                comment: res.comment
            };
            
            // Update the UI
            selectors.tonDepositComment.value = res.comment;
            selectors.tonDepositStatus.textContent = "Готово к отправке.";
    
        } catch (e) {
            selectors.tonDepositStatus.textContent = "Ошибка. Попробуйте снова.";
        } finally {
            selectors.topUpTonBtn.disabled = false;
            selectors.tonDepositLoader.style.display = 'none';
        }
    }
    async function verifyTONDeposit() {
        if (!currentDepositInfo.comment) {
            tg.showAlert("Ошибка: комментарий для проверки не найден. Пожалуйста, начните процесс пополнения заново.");
            return;
        }
    
        selectors.verifyTonDepositBtn.disabled = true;
        selectors.tonDepositStatus.textContent = "Проверяем транзакцию в блокчейне...";
        selectors.tonDepositLoader.style.display = 'block';
        try {
            // Use the stored comment instead of reading from the input
            const res = await apiRequest('/api/verify_ton_deposit', 'POST', { comment: currentDepositInfo.comment });
            if (res.status === 'success') {
                tg.showAlert(res.message);
                currentUser.balance = res.new_balance;
                updateBalanceUI();
                selectors.depositTonModal.style.display = 'none';
            } else {
                selectors.tonDepositStatus.textContent = res.message;
            }
        } catch (e) {
            selectors.tonDepositStatus.textContent = "Ошибка проверки. Попробуйте еще раз.";
        } finally {
            selectors.verifyTonDepositBtn.disabled = false;
            selectors.tonDepositLoader.style.display = 'none';
        }
    }
    async function handleTopUpStars() {
        const amount = parseInt(selectors.depositAmountInput.value);
        if (isNaN(amount) || amount < 1) { tg.showAlert("Пожалуйста, введите корректную сумму звезд для пополнения."); return; }
        selectors.topUpStarsBtn.disabled = true;
        try {
            const res = await apiRequest('/api/create_stars_invoice', 'POST', { amount });
            tg.openInvoice(res.invoice_link, async (status) => {
                if (status === 'paid') {
                    tg.showAlert("Оплата прошла успешно! Баланс обновляется...");
                    const userData = await apiRequest('/api/user_data', 'POST', {});
                    currentUser = userData;
                    updateBalanceUI();
                } else { tg.showAlert(`Статус оплаты: ${status}.`); }
            });
        } finally { selectors.topUpStarsBtn.disabled = false; }
    }

    selectors.navButtons.forEach(b => b.addEventListener('click', () => switchView(b.dataset.view)));
    selectors.collapsibleHeader.addEventListener('click', () => { selectors.collapsibleContent.classList.toggle('open'); selectors.toggleIcon.classList.toggle('open'); });
    selectors.riskButtons.forEach(b => b.addEventListener('click', () => setupBoard(b.dataset.risk)));
    selectors.dropButton.addEventListener('click', () => performDrop(false));
    selectors.betAmountInput.addEventListener('change', handleBetChange);
    selectors.stepperButtons.forEach(b => b.addEventListener('click', handleStepper));
    window.addEventListener('resize', () => setupBoard(currentRisk));
    selectors.topUpTonBtn.addEventListener('click', handleTopUpTON);
    selectors.topUpStarsBtn.addEventListener('click', handleTopUpStars);
    selectors.topUpGiftsBtn.addEventListener('click', () => selectors.depositGiftsModal.style.display = 'flex');
    selectors.closeGiftsModalBtn.addEventListener('click', () => selectors.depositGiftsModal.style.display = 'none');
    selectors.verifyTonDepositBtn.addEventListener('click', verifyTONDeposit);
    selectors.closeTonDepositModalBtn.addEventListener('click', () => selectors.depositTonModal.style.display = 'none');
    selectors.claimFreeDropBtn.addEventListener('click', handleClaimFreeDrop);
    selectors.openWalletBtn = document.getElementById('open-wallet-btn');

    // Then add the event listener
    selectors.openWalletBtn.addEventListener('click', () => {
        if (!currentDepositInfo.address || !currentDepositInfo.comment) {
            tg.showAlert("Ошибка: данные для депозита не были загружены. Пожалуйста, закройте и попробуйте снова.");
            return;
        }
    
        const amountStr = selectors.depositAmountInput.value;
        let amountNanoTON = '';
    
        if (amountStr && parseFloat(amountStr) > 0) {
            // Convert TON to nanotons (1 TON = 10^9 nanotons)
            amountNanoTON = `&amount=${Math.floor(parseFloat(amountStr) * 1e9)}`;
        }
    
        const encodedComment = encodeURIComponent(currentDepositInfo.comment);
        
        // Construct the ton:// URL
        const tonUrl = `ton://transfer/${currentDepositInfo.address}?text=${encodedComment}${amountNanoTON}`;
        
        // Open the link
        // Using an anchor tag is more robust on some mobile devices
        const link = document.createElement('a');
        link.href = tonUrl;
        link.target = '_blank';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });
    initializeApp();
});
</script>
</body>
</html>
