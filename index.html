<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Плинко</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0f1a; --surface-color: #1a1e3a; --surface-color-2: #252a4a;
            --border-color: rgba(255, 255, 255, 0.1); --text-color: #e2e8f0; --text-muted: #8a99b5;
            --button-primary-bg: linear-gradient(45deg, #a855f7, #6d28d9); --button-primary-text-color: #ffffff;
            --peg-color: #a3b8d9; --chip-color: #00f5ff; --highlight-primary: #a855f7; --highlight-secondary: #00f5ff;
            --button-secondary-bg: linear-gradient(45deg, #ec4899, #d946ef); --stepper-bg: #2c336b;
            --slot-high: #8e44ad; --slot-mid: #5a57c4; --slot-low: #3d4a99; --slot-zero: #2c336b; --nav-height: 70px; 
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        
        html {
            height: 100%;
            /* This is the key to responsive design. It makes all 'rem' units scale smoothly. */
            font-size: clamp(14px, 4.2vw, 16px);
        }
        
        body {
            font-family: 'Poppins', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center;
            min-height: 100vh; /* Use viewport height for better mobile support */
            min-height: -webkit-fill-available; /* iOS fix */
            /* Use rem for padding so it scales down on small screens */
            padding: 2rem 1rem calc(var(--nav-height) + 1.5rem);
            overflow-y: auto;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            background: linear-gradient(-45deg, #0d0f1a, #1a1e3a, #2c336b, #1a1e3a);
            background-size: 400% 400%;
            animation: gradient-animation 25s ease infinite;
        }
        #app-container { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 1rem; }
        .view { display: none; flex-direction: column; align-items: center; width: 100%; gap: 1rem; }
        .view.active { display: flex; }
        header { width: 100%; text-align: center; margin-bottom: 0.3rem; }
        header h1 {
            font-size: clamp(1.8rem, 7vw, 2.2rem);
            font-weight: 700; text-transform: uppercase; letter-spacing: 0.125rem;
            color: white; background: linear-gradient(90deg, var(--highlight-secondary), var(--highlight-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 1.25rem rgba(168, 85, 247, 0.3); margin: 0;
        }
        .game-board-area { width: 100%; }
        #plinko-board-container { position: relative; width: 100%; flex-shrink: 0; }
        @keyframes pulse-button {
            0%, 100% { transform: scale(1); box-shadow: 0 0.3rem 1rem rgba(0,0,0,0.2); }
            50% { transform: scale(1.03); box-shadow: 0 0.5rem 1.5rem rgba(168, 85, 247, 0.3); }
        }
        @keyframes cosmic-flow {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        .main-button:not(:disabled) { animation: pulse-button 3s ease-in-out infinite; }
        @keyframes pulse-glow {
            0% { box-shadow: inset 0 0 1.5rem rgba(0,0,0,0.7), 0 0 1.25rem rgba(168, 85, 247, 0.2); }
            50% { box-shadow: inset 0 0 1.5rem rgba(0,0,0,0.7), 0 0 2.2rem rgba(0, 245, 255, 0.4); }
            100% { box-shadow: inset 0 0 1.5rem rgba(0,0,0,0.7), 0 0 1.25rem rgba(168, 85, 247, 0.2); }
        }
        #plinko-board {
            width: 100%; aspect-ratio: 1 / 1; position: relative; border-radius: 1.25rem 1.25rem 0 0;
            overflow: hidden; border: 1px solid var(--border-color); border-bottom: none;
            background: linear-gradient(-45deg, var(--surface-color), #2c336b, var(--surface-color-2), var(--highlight-primary));
            background-size: 300% 300%; animation: cosmic-flow 20s ease infinite, pulse-glow 5s ease-in-out infinite;
            box-shadow: inset 0 0 1.5rem rgba(0,0,0,0.7);
        }
        @keyframes scanline { 0% { transform: translateY(-100px); } 100% { transform: translateY(100px); } }
        #plinko-board::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
            background-image: repeating-linear-gradient(to right, transparent, transparent 49.5%, rgba(163, 184, 217, 0.1) 50%, transparent 50.5%, transparent 100%),
                              repeating-linear-gradient(to bottom, transparent, transparent 49.5%, rgba(163, 184, 217, 0.1) 50%, transparent 50.5%, transparent 100%);
            background-size: 1.875rem 1.875rem; mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
            animation: scanline 4s linear infinite alternate;
        }
        .peg { width: 0.5rem; height: 0.5rem; background-color: var(--peg-color); border-radius: 50%; position: absolute; box-shadow: 0 0 0.3rem rgba(163, 184, 217, 0.3); transform: translate(-50%, -50%); z-index: 5;}
        .chip { position: absolute; background-color: var(--chip-color); border-radius: 50%; box-shadow: 0 0 0.5rem var(--chip-color), 0 0 1rem var(--chip-color); visibility: hidden; transform: translate(-50%, -50%); transition: width 0.3s, height 0.3s; will-change: transform, box-shadow; }
        #slots-container {
            display: flex; width: 100%; border-radius: 0 0 1.25rem 1.25rem;
            overflow: hidden; border: 1px solid var(--border-color); border-top: none;
            background: linear-gradient(to right, var(--slot-high), var(--slot-mid), var(--slot-low), var(--slot-zero), var(--slot-low), var(--slot-mid), var(--slot-high));
        }
        .slot {
            flex-grow: 1; height: clamp(35px, 12vw, 45px); display: flex; justify-content: center;
            align-items: center; font-weight: 600; font-size: 0.75rem; color: white;
            transition: all 0.3s ease; background-color: transparent; 
        }
        .slot img { max-height: 80%; width: auto; object-fit: contain; }
        @keyframes highlight-win { 0% { transform: scale(1); } 50% { transform: scale(1.1); filter: brightness(2) drop-shadow(0 0 1rem var(--highlight-secondary)); } 100% { transform: scale(1); } }
        @keyframes gradient-animation { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        .background-orb { position: fixed; border-radius: 50%; filter: blur(80px); opacity: 0.4; z-index: -1; }
        @keyframes float-orb { 0%, 100% { transform: translate(0, 0) scale(1); } 25% { transform: translate(40px, -60px) scale(1.1); } 50% { transform: translate(-30px, 50px) scale(0.9); } 75% { transform: translate(50px, 20px) scale(1.2); } }
        .slot.highlight { animation: highlight-win 0.6s ease-out; z-index: 10; }
        .panel { background-color: var(--surface-color); padding: 0.75rem; border-radius: 1.25rem; width: 100%; display: flex; flex-direction: column; gap: 0.625rem; border: 1px solid var(--border-color); box-shadow: 0 0.625rem 1.875rem rgba(0,0,0,0.3); }
        .balance-display { display: flex; justify-content: space-between; align-items: center; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 0.75rem; padding: 0.5rem 1rem; }
        .balance-display label { font-size: 0.9rem; color: var(--text-muted); font-weight: 500; }
        .balance-display .value { background: none; border: none; outline: none; color: var(--text-color); font-size: 1.25rem; font-weight: 600; text-align: right; display: flex; align-items: center; }
        .main-button { width: 100%; padding: 1rem; font-weight: 700; font-size: 1.125rem; cursor: pointer; border: none; border-radius: 0.75rem; color: var(--button-primary-text-color); text-shadow: 0 0.06rem 0.18rem rgba(0,0,0,0.3); box-shadow: 0 0.3rem 1rem rgba(0,0,0,0.2); transition: all 0.2s ease; display: flex; justify-content: center; align-items: center; background: var(--button-primary-bg); }
        .main-button:hover:not(:disabled) { transform: translateY(-0.18rem); box-shadow: 0 0.5rem 1.5rem rgba(0,0,0,0.3); filter: brightness(1.1); }
        .main-button:active:not(:disabled) { transform: translateY(-0.06rem); }
        .main-button:disabled { background: #4a5568 !important; cursor: not-allowed; transform: none; box-shadow: none; filter: none; }
        #bottom-nav { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 500px; height: var(--nav-height); background-color: var(--surface-color); display: flex; justify-content: space-around; align-items: center; box-shadow: 0 -0.3rem 1.875rem rgba(0,0,0,0.3); border-top: 1px solid var(--border-color); z-index: 100; }
        .nav-button { background: none; border: none; color: var(--text-muted); font-family: 'Poppins', sans-serif; font-size: 0.75rem; font-weight: 600; cursor: pointer; padding: 0.625rem; display: flex; flex-direction: column; align-items: center; gap: 0.25rem; opacity: 0.7; transition: all 0.3s ease; position: relative; }
        .nav-button.active { color: var(--highlight-primary); opacity: 1; transform: translateY(-0.18rem); }
        .nav-button.active::after { content: ''; position: absolute; bottom: -0.3rem; left: 50%; transform: translateX(-50%); width: 0.375rem; height: 0.375rem; border-radius: 50%; background-color: var(--highlight-primary); }
        .nav-button svg { width: 1.5rem; height: 1.5rem; fill: currentColor; }
        .info-text { text-align: center; color: var(--text-muted); margin-bottom: 1.25rem; line-height: 1.6; }
        #profile-avatar { width: 100px; height: 100px; border-radius: 50%; border: 0.18rem solid var(--highlight-primary); margin: 0 auto 1rem auto; display: flex; align-items: center; justify-content: center; font-size: 3rem; font-weight: 700; object-fit: cover; background-color: var(--surface-color-2); box-shadow: 0 0 1.25rem rgba(168, 85, 247, 0.4); overflow: hidden; }
        #profile-name { text-align: center; font-size: 1.8rem; font-weight: 700; }
        #profile-username { text-align: center; color: var(--text-muted); font-size: 1rem; margin-bottom: 1.5rem; }
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(10,10,20,0.7); backdrop-filter: blur(8px); align-items: center; justify-content: center; }
        .modal-content { background-color: var(--surface-color); padding: 1.25rem; border-radius: 1rem; width: 90%; max-width: 400px; box-shadow: 0 0.625rem 1.875rem rgba(0,0,0,0.4); border: 1px solid var(--border-color); }
        .modal-content h3 { margin-top: 0; }
        .modal-body { margin: 1rem 0; } .modal-actions { display: flex; gap: 0.625rem; } .modal-actions .button { flex-grow: 1; }
        #deposit-ton-modal input { width: 100%; padding: 0.625rem; border-radius: 0.5rem; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); margin-bottom: 0.625rem; text-align: center; }
        .loader { border: 4px solid #3a3f78; border-top: 4px solid var(--highlight-primary); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 1rem auto; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #deposit-amount-input { width: 100%; padding: 0.75rem; border-radius: 0.75rem; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); text-align: center; font-size: 1.1rem; }
        
        #bet-mode-selector {
            display: flex; background-color: var(--bg-color); border-radius: 0.75rem;
            padding: 0.25rem; margin-bottom: 0.625rem; border: 1px solid var(--border-color); gap: 0.3rem;
        }
        .bet-mode-button {
            flex-grow: 1; padding: 0.75rem 0.3rem; border: none; background: none; border-radius: 0.5rem;
            color: var(--text-muted); font-family: 'Poppins', sans-serif; font-weight: 600;
            font-size: 1rem; cursor: pointer; transition: all 0.3s ease;
            display: flex; align-items: center; justify-content: center; /* Center content */
        }
        .bet-mode-button.active {
            background: var(--button-primary-bg); color: white;
            box-shadow: 0 0 0.625rem rgba(168, 85, 247, 0.4);
        }
        /* Style for the star image inside the bet buttons */
        .bet-mode-button img {
            height: 1.2em; /* Scales with the button's font size */
            vertical-align: -0.15em;
            margin-left: 0.25rem;
        }
        
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 9999; display: flex; flex-direction: column; justify-content: center;
            align-items: center; background: linear-gradient(-45deg, #0d0f1a, #1a1e3a, #2c336b, #1a1e3a);
            background-size: 400% 400%; animation: gradient-animation 25s ease infinite;
            color: var(--text-color); transition: opacity 0.5s ease-out;
        }
        
        #loading-screen.hidden { opacity: 0; pointer-events: none; }
        
        #lottie-animation { width: 150px; height: 150px; margin-bottom: 1.25rem; }
        
        #loading-screen h1 {
            font-size: 2.5rem; font-weight: 700; letter-spacing: 0.125rem;
            text-transform: uppercase; background: linear-gradient(90deg, var(--highlight-secondary), var(--highlight-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 1.25rem rgba(168, 85, 247, 0.3);
        }
        
        #loading-screen p { margin-top: 1rem; font-size: 1rem; color: var(--text-muted); font-weight: 500; }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="lottie-animation"></div>
        <h1>Plinko Gifts</h1>
        <p id="loading-text">Инициализация...</p>
    </div>
    <div class="background-orb" style="width: 400px; height: 400px; top: -150px; left: -150px; background-color: var(--highlight-primary); animation: float-orb 20s infinite ease-in-out;"></div>
    <div class="background-orb" style="width: 300px; height: 300px; bottom: -100px; right: -100px; background-color: var(--highlight-secondary); animation: float-orb 25s infinite ease-in-out reverse;"></div>
    <div id="app-container">
        <!-- Main Game View -->
        <div id="main-game-view" class="view active">
            <header><h1>Plinko</h1></header>
            <div class="game-board-area">
                <div id="plinko-board-container"><div id="plinko-board"></div></div>
                <div id="slots-container"></div>
            </div>
            <div class="panel">
                <div class="balance-display"><label>Баланс</label><div id="balance" class="value">0.00</div></div>
                <div id="bet-mode-selector">
                    <button class="bet-mode-button active" data-bet="200">200 ✨</button>
                    <button class="bet-mode-button" data-bet="1000">1000 ✨</button>
                    <button class="bet-mode-button" data-bet="4000">4000 ✨</button>
                </div>
                <button id="drop-button" class="main-button">Бросить</button>
            </div>
        </div>
        <!-- Free Try View -->
        <div id="free-try-view" class="view">
            <header><h1>Free Try</h1></header>
            <div class="panel">
                <p class="info-text">Получайте бесплатный бросок (ставка 2.5 Stars) каждые 24 часа!</p>
                <div id="timer-container" style="text-align:center; margin: 20px 0;">
                    <h2 id="timer" style="font-size: 2.5rem; color: var(--highlight-secondary); margin-bottom: 5px;">00:00:00</h2>
                    <span style="color: var(--text-muted);">До следующего броска</span>
                </div>
                <button id="claim-free-drop-btn" class="main-button">Забрать бросок</button>
            </div>
        </div>
        <!-- Profile View -->
        <div id="profile-view" class="view">
            <header><h1>Профиль</h1></header>
            <div class="panel">
                <div id="profile-avatar">?</div>
                <h2 id="profile-name">Пользователь</h2><p id="profile-username">@username</p>
                <div class="balance-display"><label>Баланс</label><div id="profile-balance" class="value">0.00</div></div>
                <h3 style="text-align:center; margin:15px 0 10px; font-size:1.1rem; color:var(--text-muted);">Пополнить баланс</h3>
                <input type="number" id="deposit-amount-input" placeholder="Сумма в Stars" style="margin-bottom: 15px;">
                
                <p style="text-align:center; margin:0 0 8px; font-size:0.9rem; color:var(--text-muted);">Пополнить с помощью:</p>
                <div style="display:flex; gap:10px;">
                    <!-- TON button is now hidden but kept in the code -->
                    <button id="topup-ton-btn" class="main-button" style="display: none;">Пополнить через TON</button>
                    
                    <!-- Stars and Gifts buttons are in one row, smaller, with new text -->
                    <button id="topup-stars-btn" class="main-button" style="background: var(--button-secondary-bg); flex-grow: 1; padding: 12px 5px; font-size: 1rem;">Звёзды</button>
                    <button id="topup-gifts-btn" class="main-button" style="background: var(--surface-color-2); flex-grow: 1; padding: 12px 5px; font-size: 1rem;">Подарки</button>
                </div>
                <div id="inventory-section" style="margin-top: 25px;">
                <h3 style="text-align:center; color:var(--text-muted);">Инвентарь Подарков</h3>
                <div id="inventory-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 15px; max-height: 400px; overflow-y: auto; padding: 5px;">
                    <p id="inventory-placeholder" style="grid-column: 1 / -1; text-align: center; color: var(--text-muted);">Инвентарь пуст.</p>
                </div>
            </div>
            </div>
        </div>
    </div>
    <!-- Bottom Navigation -->
    <nav id="bottom-nav">
        <button class="nav-button" data-view="free-try-view"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,6H18.18C18.09,5.69 18,5.35 18,5A3,3 0 0,0 15,2C13.95,2 13.04,2.54 12.5,3.35C11.96,2.54 11.05,2 10,2A3,3 0 0,0 7,5C7,5.35 7.09,5.69 7.18,6H4A2,2 0 0,0 2,8V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V8A2,2 0 0,0 20,6M15,4A1,1 0 0,1 16,5A1,1 0 0,1 15,6A1,1 0 0,1 14,5A1,1 0 0,1 15,4M10,4A1,1 0 0,1 11,5A1,1 0 0,1 10,6A1,1 0 0,1 9,5A1,1 0 0,1 10,4M20,19H4V8H20V19Z" fill="currentColor"/></svg><span>Free Try</span></button>
        <button class="nav-button active" data-view="main-game-view"><svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg><span>Игра</span></button>
        <button class="nav-button" data-view="profile-view"><svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg><span>Профиль</span></button>
    </nav>

    <!-- Modals -->
    <div id="deposit-ton-modal" class="modal">
        <div class="modal-content">
            <h3>Депозит через TON</h3>
            <div class="modal-body" style="text-align: center;">
                <p>Отправьте любую сумму TON. Ваш баланс будет пополнен в Stars по курсу <strong style="color: var(--highlight-secondary);">1 TON = 250 Stars</strong>.</p>
                <div style="margin: 15px 0;">
                    <strong style="color: var(--text-muted);">ВАШ УНИКАЛЬНЫЙ КОММЕНТАРИЙ:</strong><br>
                    <input type="text" id="ton-deposit-comment" readonly style="background-color: var(--bg-color); border-color: #ff9800; text-align: center; font-weight: bold; margin-top: 5px;">
                    <p style="color: #ff9800; font-size: 0.8rem; margin-top: 5px;"><strong>НЕ ИЗМЕНЯЙТЕ ЭТОТ КОММЕНТАРИЙ В КОШЕЛЬКЕ!</strong></p>
                </div>
                <div id="ton-deposit-loader" class="loader" style="display:none;"></div>
                <p id="ton-deposit-status"></p>
            </div>
            <div class="modal-actions" style="flex-direction: column; gap: 12px;">
                <button id="open-wallet-btn" class="main-button">Открыть кошелек</button>
                <button id="verify-ton-deposit-btn" class="main-button" style="background: var(--surface-color-2);">Я уже оплатил (Проверить)</button>
                <button id="close-ton-deposit-modal-btn" class="main-button" style="background: var(--stepper-bg);">Отмена</button>
            </div>
        </div>
    </div>
    <div id="deposit-gifts-modal" class="modal">
        <div class="modal-content">
            <h3>Депозит Подарками</h3>
            <div class="modal-body" style="text-align: center;">
                <p>Для пополнения подарками, просто переведите подарок @relayerplinko, он автоматически зачислится на ваш баланс.</p>
                
                <!-- Collapsible Price List Section -->
                <details style="margin: 20px 0;">
                    <summary style="cursor: pointer; color: var(--highlight-primary); font-weight: 600;">Показать/скрыть цены на подарки</summary>
                    <div id="gift-price-list" style="margin-top: 15px; max-height: 300px; overflow-y: auto; text-align: left; padding: 10px; background-color: var(--bg-color); border-radius: 8px;">
                        <p>Загрузка цен...</p>
                    </div>
                </details>

            </div>
            <div class="modal-actions" style="flex-direction: column;">
                <a href="https://t.me/relayerplinko" target="_blank" class="main-button" style="text-decoration: none;">@relayerplinko</a>
                <button id="close-gifts-modal-btn" class="main-button" style="background: var(--stepper-bg);">Закрыть</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- START: Loading Screen Logic ---
    const loadingScreen = document.getElementById('loading-screen');
    const loadingText = document.getElementById('loading-text');

    // Initialize Lottie Animation using the provided URL
    lottie.loadAnimation({
        container: document.getElementById('lottie-animation'),
        renderer: 'svg',
        loop: true,
        autoplay: true,
        path: 'https://cdn.changes.tg/gifts/models/Jolly%20Chimp/lottie/Toddler.json'
    });

    const funnyPhrases = [
        "Загружаю подарочки...",
        "Чищу баги в коде...",
        "Корректирую ценники...",
        "Подкручиваю вам удачу...",
        "Проверяю подписки...",
        "Разгоняю пиксели...",
        "Настраиваю гравитацию шарика..."
    ];
    let phraseIndex = 0;
    const textInterval = setInterval(() => {
        phraseIndex = (phraseIndex + 1) % funnyPhrases.length;
        loadingText.textContent = funnyPhrases[phraseIndex];
    }, 2000); // Change text every 2 seconds

    function hideLoadingScreen() {
        clearInterval(textInterval);
        loadingText.textContent = "Готово!";
        
        // Wait a moment so the user sees "Готово!"
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
            // After the fade-out animation finishes, remove it from the display
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500); // This duration must match the CSS transition duration
        }, 800); 
    }
    // --- END: Loading Screen Logic ---
    const tg = window.Telegram.WebApp;
    const API_BASE_URL = 'https://plinko-4vm7.onrender.com';
    const STAR_ICON_HTML = `<img src="https://github.com/Vasiliy-katsyka/plinko/blob/main/star.png?raw=true" alt="Stars" style="height: 1em; vertical-align: -0.1em; margin-left: 4px;">`;

    let currentUser = { id: null, balance: 0.00 };
    let isDropping = false;
    let activeChips = [];
    let chipIdCounter = 0;
    let boardSeed = null;
    let pegs = [];
    let BOARD_WIDTH, BOARD_HEIGHT, CHIP_RADIUS, PEG_RADIUS;
    let GRAVITY = 0.25, DAMPING = 0.55;
    let freeDropTimerInterval = null;
    let currentDepositInfo = { address: '', comment: '' };

    let currentBetMode = '200';
    const NUM_ROWS = 8;

    const selectors = {
        views: document.querySelectorAll('.view'),
        navButtons: document.querySelectorAll('.nav-button'),
        balance: document.getElementById('balance'),
        profileBalance: document.getElementById('profile-balance'),
        profileName: document.getElementById('profile-name'),
        profileUsername: document.getElementById('profile-username'),
        profileAvatar: document.getElementById('profile-avatar'),
        board: document.getElementById('plinko-board'),
        slotsContainer: document.getElementById('slots-container'),
        dropButton: document.getElementById('drop-button'),
        betModeButtons: document.querySelectorAll('.bet-mode-button'),
        topUpTonBtn: document.getElementById('topup-ton-btn'),
        topUpStarsBtn: document.getElementById('topup-stars-btn'),
        topUpGiftsBtn: document.getElementById('topup-gifts-btn'),
        depositAmountInput: document.getElementById('deposit-amount-input'),
        depositTonModal: document.getElementById('deposit-ton-modal'),
        tonDepositComment: document.getElementById('ton-deposit-comment'),
        verifyTonDepositBtn: document.getElementById('verify-ton-deposit-btn'),
        openWalletBtn: document.getElementById('open-wallet-btn'),
        closeTonDepositModalBtn: document.getElementById('close-ton-deposit-modal-btn'),
        tonDepositLoader: document.getElementById('ton-deposit-loader'),
        tonDepositStatus: document.getElementById('ton-deposit-status'),
        depositGiftsModal: document.getElementById('deposit-gifts-modal'),
        closeGiftsModalBtn: document.getElementById('close-gifts-modal-btn'),
        timerElement: document.getElementById('timer'),
        claimFreeDropBtn: document.getElementById('claim-free-drop-btn'),
        inventoryContainer: document.getElementById('inventory-container'),
        inventoryPlaceholder: document.getElementById('inventory-placeholder')
    };
    
    async function apiRequest(endpoint, method = 'POST', body = {}) {
        const config = {
            method,
            headers: { 'Content-Type': 'application/json', 'X-Telegram-Init-Data': tg.initData }
        };
        if (method.toUpperCase() !== 'GET') { config.body = JSON.stringify(body); }
        try {
            const response = await fetch(API_BASE_URL + endpoint, config);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error ${response.status}`);
            }
            return response.json();
        } catch (error) {
            tg.showAlert(error.message);
            throw error;
        }
    }

    async function initializeApp() {
        try {
            tg.ready(); 
            tg.expand();
            
            // This is where the app waits for the server
            const userData = await apiRequest('/api/user_data', 'POST', {});
            
            // Once data is loaded, we set everything up
            currentUser = userData;
            updateBalanceUI();
            updateProfileUI();
            setupBoard();
            loadInventory(); // Pre-load inventory
        } catch (error) {
            console.error("Failed to load user data:", error);
            tg.showAlert("Не удалось загрузить данные пользователя.");
        } finally {
            // This 'finally' block ensures the loading screen is hidden
            // whether the app loads successfully or fails.
            hideLoadingScreen();
        }
    }

    function updateBalanceUI() {
        const formattedBalance = `${currentUser.balance.toFixed(2)} ${STAR_ICON_HTML}`;
        selectors.balance.innerHTML = formattedBalance;
        selectors.profileBalance.innerHTML = formattedBalance;
    }

    function updateProfileUI() {
        selectors.profileName.textContent = currentUser.first_name || "User";
        selectors.profileUsername.textContent = currentUser.username ? `@${currentUser.username}` : `#${currentUser.id}`;
        selectors.profileAvatar.innerHTML = '';
        if (currentUser.photo_url) {
            const img = document.createElement('img');
            img.src = currentUser.photo_url;
            img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
            selectors.profileAvatar.appendChild(img);
            selectors.profileAvatar.style.cssText = 'padding: 0; font-size: 0;';
        } else {
            selectors.profileAvatar.textContent = (currentUser.first_name || "?").charAt(0);
            selectors.profileAvatar.style.cssText = '';
        }
    }

    function addGiftToInventoryUI(item) {
        const selectors = {
            inventoryContainer: document.getElementById('inventory-container'),
            inventoryPlaceholder: document.getElementById('inventory-placeholder')
        };
        
        if (selectors.inventoryPlaceholder) {
            selectors.inventoryPlaceholder.style.display = 'none';
        }
    
        const itemEl = document.createElement('div');
        // --- CHANGE IS HERE ---
        // Added a specific class 'inventory-item' to the container for easy selection
        itemEl.className = 'inventory-item'; 
        itemEl.style.cssText = `background-color: var(--surface-color-2); border: 1px solid var(--border-color); border-radius: 12px; padding: 8px; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: space-between;`;
        
        const itemId = item.inventory_id || `new-${Date.now()}`;
        const emojiGiftNames = ["Heart", "Bear", "Rose", "Rocket", "Bottle", "Ring"];
        const isEmojiGift = emojiGiftNames.includes(item.name);
        const withdrawButtonHTML = isEmojiGift
            ? `<button class="main-button" disabled style="background: var(--stepper-bg); flex-grow: 1; font-size: 0.7rem; padding: 6px 4px; height: auto; margin-top: 8px;">Вывод недоступен</button>`
            : `<button class="withdraw-btn main-button" data-id="${itemId}" data-name="${item.name}" style="background: var(--button-secondary-bg); flex-grow: 1; font-size: 0.7rem; padding: 6px 4px; height: auto; margin-top: 8px;">Вывести</button>`;
    
        itemEl.innerHTML = `
            <img src="${item.imageUrl}" style="width: 60px; height: 60px; object-fit: contain;">
            
            <!-- CHANGE IS HERE -->
            <span style="font-size: 0.7rem; color: var(--text-muted); margin-top: 5px;">${formatGiftName(item.name)}</span>
            
            <div style="display:flex; gap: 5px; width: 100%;">
                <button class="convert-btn main-button" data-id="${itemId}" data-value="${item.value}" style="flex-grow: 1; font-size: 0.7rem; padding: 6px 4px; margin-top: 8px; height: auto;">${Math.round(item.value)} ${STAR_ICON_HTML}</button>
                ${withdrawButtonHTML}
            </div>
        `;
        
        selectors.inventoryContainer.prepend(itemEl);
        
        // The main event listener on the parent container handles clicks, so no need to add listeners here.
    }

    async function loadGiftPrices() {
        const listContainer = document.getElementById('gift-price-list');
        try {
            const response = await fetch(API_BASE_URL + '/api/get_all_gift_prices');
            if (!response.ok) throw new Error('Network response was not ok');
            const gifts = await response.json();

            if (gifts.length === 0) {
                listContainer.innerHTML = '<p>Не удалось загрузить цены.</p>';
                return;
            }

            let html = '<ul style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 8px;">';
            gifts.forEach(gift => {
                html += `
                    <li style="display: flex; align-items: center; gap: 10px; font-size: 0.9rem;">
                        <img src="${gift.imageUrl}" alt="${gift.name}" style="width: 32px; height: 32px; object-fit: contain;">
                        <span style="flex-grow: 1;">${gift.name}</span>
                        <strong style="color: var(--highlight-secondary);">${Math.round(gift.value)}</strong>
                        <img src="https://github.com/Vasiliy-katsyka/plinko/blob/main/star.png?raw=true" alt="Stars" style="height: 1em; vertical-align: -0.1em;">
                    </li>
                `;
            });
            html += '</ul>';
            listContainer.innerHTML = html;

        } catch (error) {
            console.error("Failed to load gift prices:", error);
            listContainer.innerHTML = '<p>Ошибка загрузки цен.</p>';
        }
    }

    // Call the function when the deposit modal is opened
    selectors.topUpGiftsBtn.addEventListener('click', () => {
        selectors.depositGiftsModal.style.display = 'flex';
        loadGiftPrices(); // Load prices every time modal is opened
    });
    
    document.getElementById('inventory-container').addEventListener('click', function(event) {
        // Use .closest() to ensure we get the button even if an inner element (like an icon) is clicked
        const button = event.target.closest('button');
        if (!button) return; // Exit if the click wasn't on a button or inside one
    
        if (button.classList.contains('withdraw-btn')) {
            handleWithdrawGift(button);
        } else if (button.classList.contains('convert-btn')) {
            handleConvertGift(button);
        }
    });
    
    async function handleWithdrawGift(button) {
        const itemContainer = button.closest('.inventory-item');
        if (!itemContainer) return;
    
        const actionButtons = itemContainer.querySelectorAll('button');
        const inventoryId = button.dataset.id;
        const giftName = button.dataset.name;
    
        if (!confirm(`Вы уверены, что хотите вывести подарок "${formatGiftName(giftName)}"? Он будет отправлен вам в личные сообщения в Telegram.`)) {
            return;
        }
    
        // *** FIX for abuse: Disable all buttons on this item.
        actionButtons.forEach(btn => btn.disabled = true);
        button.textContent = '...';
    
        try {
            const response = await apiRequest('/api/create_withdrawal_task', 'POST', { inventory_id: inventoryId });
            if (response.status === 'success') {
                tg.showAlert("Запрос на вывод создан! Подарок будет отправлен вам в течение минуты.");
                itemContainer.remove(); // Remove the entire item container
            } else {
                tg.showAlert(response.error || 'Не удалось создать запрос на вывод.');
                // On failure, re-enable buttons
                actionButtons.forEach(btn => btn.disabled = false);
                button.textContent = 'Вывести';
            }
        } catch (e) {
            // On error, re-enable buttons
            actionButtons.forEach(btn => btn.disabled = false);
            button.textContent = 'Вывести';
        }
    }
    
    function switchView(viewId) {
        if (freeDropTimerInterval) { clearInterval(freeDropTimerInterval); freeDropTimerInterval = null; }
        selectors.views.forEach(v => v.classList.toggle('active', v.id === viewId));
        selectors.navButtons.forEach(b => b.classList.toggle('active', b.dataset.view === viewId));
        if (viewId === 'free-try-view') initFreeTryView();
    }
    
    async function updateBoardSlots() {
        try {
            // Generate a new random seed for this board layout
            boardSeed = Math.random().toString(36).substring(2); 
    
            // Send the current bet mode AND the new seed to the backend
            const response = await apiRequest('/api/get_board_slots', 'POST', { 
                betMode: currentBetMode,
                seed: boardSeed // <--- SEND THE SEED
            });
    
            selectors.slotsContainer.innerHTML = '';
            response.slots.forEach(slotData => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.innerHTML = `<img src="${slotData.imageUrl}" title="${slotData.name} (~${Math.round(slotData.value)} Stars)" style="height: 80%; object-fit: contain;">`;
                selectors.slotsContainer.appendChild(slot);
            });
        } catch (error) {
            console.error("Failed to update board slots:", error);
            tg.showAlert("Не удалось загрузить оформление для слотов.");
        }
    }

    async function handleSingleDrop() {
        const betAmount = parseInt(currentBetMode, 10);
        if (betAmount > currentUser.balance) { tg.showAlert("Недостаточно средств!"); return; }
        
        setControlsDisabled(true);
        
        // Temporarily reduce balance on the frontend for responsiveness
        const originalBalance = currentUser.balance;
        currentUser.balance -= betAmount;
        updateBalanceUI();
    
        try {
            const result = await apiRequest('/api/plinko_drop', 'POST', { 
                betMode: currentBetMode,
                seed: boardSeed
            });
            
            // This part is unchanged, it runs on success
            animateSingleChip(result);
    
        } catch (error) {
            // --- CHANGE IS HERE: Handle the session error and re-enable controls ---
            // The apiRequest function already shows the alert with the error message
            console.error("Plinko drop failed:", error.message);
            
            // Restore the balance since the drop failed
            currentUser.balance = originalBalance;
            updateBalanceUI();
            
            // Re-enable the controls so the user can try again
            setControlsDisabled(false);
        }
    }
    function animateSingleChip(resultFromServer) {
        const chipId = chipIdCounter++;
        const chipEl = document.createElement('div');
        chipEl.className = 'chip';
        chipEl.style.width = `${CHIP_RADIUS * 2}px`;
        chipEl.style.height = `${CHIP_RADIUS * 2}px`;
    
        const finalSlotIndex = resultFromServer.final_slot_index;
        const targetSlot = document.querySelectorAll('.slot')[finalSlotIndex];
        const startX = BOARD_WIDTH / 2;
        let targetX = startX; 
    
        if (targetSlot) {
            const slotRect = targetSlot.getBoundingClientRect();
            const boardRect = selectors.board.getBoundingClientRect();
            targetX = (slotRect.left - boardRect.left) + (slotRect.width / 2);
        }
        
        // --- PHYSICS FIX: A much more natural initial push ---
        // Instead of a massive shove, this is a mostly random velocity with a tiny directional bias.
        // The chaos from the pegs will now do most of the work.
        const directionBias = Math.sign(targetX - startX) * 0.5; // A tiny hint (-0.5, 0, or 0.5)
        const randomPush = (Math.random() - 0.5) * 4; // A random velocity between -2 and +2
        const initialVx = directionBias + randomPush;
        // --- END PHYSICS FIX ---
    
        const newChip = {
            id: chipId, 
            x: startX, 
            y: CHIP_RADIUS, 
            vx: initialVx, // Use the new, more realistic initial velocity
            vy: 0, 
            element: chipEl, 
            serverResult: resultFromServer,
            targetX: targetX 
        };
    
        chipEl.style.transform = `translate(${newChip.x - CHIP_RADIUS}px, ${newChip.y - CHIP_RADIUS}px)`;
        chipEl.style.visibility = 'visible';
        selectors.board.appendChild(chipEl);
        activeChips.push(newChip);
        if (!isDropping) {
            isDropping = true;
            document.querySelectorAll('.slot.highlight').forEach(s => s.classList.remove('highlight'));
            requestAnimationFrame(updatePhysics);
        }
    }
    
    function setupBoard() {
        if (isDropping) return;
        BOARD_WIDTH = selectors.board.clientWidth;
        if (BOARD_WIDTH === 0) { setTimeout(setupBoard, 50); return; }
        BOARD_HEIGHT = selectors.board.clientHeight;
        const cols = NUM_ROWS + 2;
        PEG_RADIUS = BOARD_WIDTH / 150;
        CHIP_RADIUS = BOARD_WIDTH / 45;
        pegs = [];
        selectors.board.innerHTML = '';
        const hSpacing = BOARD_WIDTH / cols;
        const vSpacing = BOARD_HEIGHT / (NUM_ROWS + 1);
        for (let r = 0; r < NUM_ROWS; r++) {
            const numPegs = r % 2 === 0 ? cols - 1 : cols;
            const xOffset = r % 2 === 0 ? hSpacing : hSpacing / 2;
            for (let c = 0; c < numPegs; c++) {
                const x = xOffset + c * hSpacing;
                const y = vSpacing + r * vSpacing;
                pegs.push({ x, y });
                const pegEl = document.createElement('div');
                pegEl.className = 'peg';
                pegEl.style.cssText = `width:${PEG_RADIUS*2}px;height:${PEG_RADIUS*2}px;left:${x}px;top:${y}px;`;
                selectors.board.appendChild(pegEl);
            }
        }
        updateBoardSlots();
    }
    
    function updatePhysics() {
        if (activeChips.length === 0) {
            isDropping = false;
            setControlsDisabled(false);
            return;
        }
    
        // --- Tuned Physics Constants ---
        GRAVITY = 0.25;
        DAMPING = 0.6; // Energy retained on bounce (0.6 is a good balance)
        const maxHorizontalVelocity = 8;
        const maxVerticalVelocity = 12; // Capped to prevent tunneling through pegs
        const separationBuffer = 0.1;   // Prevents jittering on pegs
        const baseFunnelStrength = 0.04; // The max strength of the guide force at the bottom
    
        // --- Main Physics Loop ---
        for (let i = activeChips.length - 1; i >= 0; i--) {
            const chip = activeChips[i];
    
            // 1. Handle the final "Landed" state (smoothly animates into the slot)
            if (chip.landed) {
                // Calculate the slot's center X position once
                if (chip.targetCenterX === undefined) {
                    const finalSlotIndex = chip.serverResult.final_slot_index;
                    const targetSlot = document.querySelectorAll('.slot')[finalSlotIndex];
                    const boardRect = selectors.board.getBoundingClientRect();
                    chip.targetCenterX = targetSlot ? (targetSlot.getBoundingClientRect().left - boardRect.left) + (targetSlot.width / 2) : BOARD_WIDTH / 2;
                }
                // Interpolate position for a smooth landing
                chip.x += (chip.targetCenterX - chip.x) * 0.25;
                chip.y += ((BOARD_HEIGHT + CHIP_RADIUS) - chip.y) * 0.25;
                chip.element.style.transform = `translate(${chip.x - CHIP_RADIUS}px, ${chip.y - CHIP_RADIUS}px)`;
    
                // After a short delay, end the drop completely
                if (Date.now() - chip.landedTime > 250) {
                    endDrop(chip);
                    activeChips.splice(i, 1);
                }
                continue; // Skip the rest of the physics for this landed chip
            }
    
            // 2. Apply Gravity
            chip.vy += GRAVITY;
    
            // 3. Peg Collision and Bounce Logic
            const radiiSum = CHIP_RADIUS + PEG_RADIUS;
            pegs.forEach(peg => {
                const dx = chip.x - peg.x;
                const dy = chip.y - peg.y;
                const distanceSq = dx * dx + dy * dy;
    
                // Check for collision
                if (distanceSq < radiiSum * radiiSum) {
                    const dist = Math.sqrt(distanceSq);
                    const overlap = radiiSum - dist;
                    const angle = Math.atan2(dy, dx);
                    
                    // Resolve overlap by pushing the chip out, plus a small buffer
                    const pushAmount = overlap + separationBuffer;
                    chip.x += Math.cos(angle) * pushAmount;
                    chip.y += Math.sin(angle) * pushAmount;
                    
                    // Perform the bounce using a standard reflection formula
                    const normalX = dx / dist;
                    const normalY = dy / dist;
                    const dot = chip.vx * normalX + chip.vy * normalY;
                    chip.vx = (chip.vx - 2 * dot * normalX) * DAMPING;
                    chip.vy = (chip.vy - 2 * dot * normalY) * DAMPING;
    
                    // Enforce a minimum bounce when hitting the top of a peg to prevent getting stuck
                    if (chip.vy > -1 && normalY < -0.5) {
                        chip.vy = -1;
                    }
                }
            });
    
            // 4. Progressive Funneling Logic
            // The guiding force starts weak and gets stronger as the chip nears the bottom.
            const progress = Math.max(0, chip.y / BOARD_HEIGHT);
            // Math.pow(progress, 4) ensures the force is negligible until the last ~30% of the board.
            const currentFunnelStrength = baseFunnelStrength * Math.pow(progress, 4); 
            chip.vx += (chip.targetX - chip.x) * currentFunnelStrength;
            
    
            // 5. Update Position and Enforce Velocity Limits
            chip.vx = Math.max(-maxHorizontalVelocity, Math.min(maxHorizontalVelocity, chip.vx));
            chip.vy = Math.max(-maxVerticalVelocity, Math.min(maxVerticalVelocity, chip.vy));
            chip.x += chip.vx;
            chip.y += chip.vy;
    
            // 6. Wall Collision
            if (chip.x - CHIP_RADIUS < 0 || chip.x + CHIP_RADIUS > BOARD_WIDTH) {
                chip.vx *= -DAMPING; // Bounce off the wall with energy loss
                chip.x = Math.max(CHIP_RADIUS, Math.min(chip.x, BOARD_WIDTH - CHIP_RADIUS));
            }
    
            // 7. Visually Update the Chip on Screen
            chip.element.style.transform = `translate(${chip.x - CHIP_RADIUS}px, ${chip.y - CHIP_RADIUS}px)`;
            
            // 8. Check if the chip has fallen out of the board to trigger the landing state
            if (chip.y - CHIP_RADIUS > BOARD_HEIGHT) {
                chip.landed = true;
                chip.landedTime = Date.now();
            }
        }
        
        // 9. Continue the Animation Loop
        requestAnimationFrame(updatePhysics);
    }
    
    // CORRECTED endDrop function
    function endDrop(chip) {
        chip.element.remove();
        const result = chip.serverResult;
        
        if (result.won_item) {
            tg.showAlert(`Вы выиграли: ${formatGiftName(result.won_item.name)}!`);
            if (result.won_item.value > 500) {
                 tg.HapticFeedback.notificationOccurred('success');
            }
            
            currentUser.balance = result.new_balance;
            updateBalanceUI();
    
            // New: Instantly add the won gift to the inventory UI
            addGiftToInventoryUI(result.won_item);
    
        }
    
        const targetSlot = document.querySelectorAll('.slot')[result.final_slot_index];
        if (targetSlot) {
            targetSlot.classList.add('highlight');
            setTimeout(() => targetSlot.classList.remove('highlight'), 600);
        }
    }
    
    function setControlsDisabled(disabled) {
        selectors.dropButton.disabled = disabled;
        selectors.betModeButtons.forEach(b => b.disabled = disabled);
    }
    
    function getSlotColor(m) {
        if (m >= 5) return 'var(--slot-high)'; // Based on multiplier relative to bet
        if (m >= 2) return 'var(--slot-mid)';
        if (m > 0) return 'var(--slot-low)';
        return 'var(--slot-zero)';
    }

    async function loadInventory() {
        const inventoryContainer = document.getElementById('inventory-container');
        const inventoryPlaceholder = document.getElementById('inventory-placeholder');
        inventoryContainer.innerHTML = ''; // Clear previous items
        inventoryPlaceholder.style.display = 'block';
        inventoryPlaceholder.textContent = 'Загрузка...';
        try {
            const data = await apiRequest('/api/get_inventory');
            if (data.inventory && data.inventory.length > 0) {
                inventoryPlaceholder.style.display = 'none';
                // Use the new helper function to build the UI
                data.inventory.forEach(item => addGiftToInventoryUI(item));
            } else {
                inventoryPlaceholder.textContent = 'Инвентарь пуст.';
            }
        } catch (e) { inventoryPlaceholder.textContent = 'Ошибка загрузки.'; }
    }

    function formatGiftName(rawName) {
        if (!rawName) return '';
        
        // Step 1: Handle names with separators like "b-daycandle" or "durov'scap"
        let spacedName = rawName.replace(/[-']/g, ' ');
    
        // Step 2: Handle camelCase names like "jollyChimp" -> "jolly Chimp"
        // It inserts a space before any uppercase letter that is preceded by a lowercase letter.
        spacedName = spacedName.replace(/([a-z])([A-Z])/g, '$1 $2');
    
        // Step 3: Capitalize the first letter of each word
        return spacedName
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
    
    async function handleConvertGift(button) {
        const itemContainer = button.closest('.inventory-item');
        if (!itemContainer) return;
    
        const actionButtons = itemContainer.querySelectorAll('button');
        const inventoryId = button.dataset.id;
        // *** FIX for NaN bug: Store value before any async operations.
        const giftValue = button.dataset.value;
    
        // *** FIX for abuse: Disable all buttons on this item.
        actionButtons.forEach(btn => btn.disabled = true);
        button.textContent = '...';
    
        try {
            const response = await apiRequest('/api/convert_gift', 'POST', { inventory_id: inventoryId });
            if (response.status === 'success') {
                tg.HapticFeedback.notificationOccurred('success');
                currentUser.balance = response.new_balance;
                updateBalanceUI();
                itemContainer.remove(); // Remove the entire item container
                if (selectors.inventoryContainer.childElementCount === 1) {
                    selectors.inventoryPlaceholder.style.display = 'block';
                    selectors.inventoryPlaceholder.textContent = 'Инвентарь пуст.';
                }
            } else {
                tg.showAlert(response.error || 'Не удалось конвертировать подарок.');
                actionButtons.forEach(btn => btn.disabled = false);
                // *** FIX for NaN bug: Restore button text using the stored variable.
                button.innerHTML = `${Math.round(giftValue)} ${STAR_ICON_HTML}`;
            }
        } catch (e) {
            actionButtons.forEach(btn => btn.disabled = false);
            // *** FIX for NaN bug: Restore button text using the stored variable.
            button.innerHTML = `${Math.round(giftValue)} ${STAR_ICON_HTML}`;
        }
    }

    function updateFreeDropTimer() {
        const lastClaim = currentUser.last_free_drop_claim;
        if (!lastClaim) { selectors.timerElement.textContent = "Готово!"; selectors.claimFreeDropBtn.disabled = false; return; }
        const nextAvailableTime = new Date(lastClaim).getTime() + (24 * 60 * 60 * 1000);
        const timeLeft = nextAvailableTime - Date.now();
        if (timeLeft <= 0) {
            selectors.timerElement.textContent = "Готово!"; selectors.claimFreeDropBtn.disabled = false;
            if (freeDropTimerInterval) clearInterval(freeDropTimerInterval);
        } else {
            selectors.claimFreeDropBtn.disabled = true;
            const h = Math.floor(timeLeft / 36e5), m = Math.floor((timeLeft % 36e5) / 6e4), s = Math.floor((timeLeft % 6e4) / 1e3);
            selectors.timerElement.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
    }

    function initFreeTryView() { updateFreeDropTimer(); freeDropTimerInterval = setInterval(updateFreeDropTimer, 1000); }

    async function setBetModeUI(betValue) {
        if (isDropping) return;
        currentBetMode = betValue;
        
        // Update button visual state
        selectors.betModeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.bet === betValue);
        });
        
        // Asynchronously update the slots to match the new bet mode
        await updateBoardSlots();
    }
    
    
    // --- MODIFY this function ---
    async function handleClaimFreeDrop() {
        selectors.claimFreeDropBtn.disabled = true;
        try {
            const result = await apiRequest('/api/claim_free_drop', 'POST', {});
            if (result.status === 'success') {
                
                // --- CHANGE IS HERE: Set UI to 200 mode before animating ---
                await setBetModeUI('200'); 
                
                currentUser.last_free_drop_claim = result.new_claim_time;
                switchView('main-game-view');
                currentUser.balance = result.game_result.new_balance; 
                updateBalanceUI();
                animateSingleChip(result.game_result);
                
            } else { 
                tg.showAlert(result.message); 
                selectors.claimFreeDropBtn.disabled = false; 
            }
        } catch (e) { 
            selectors.claimFreeDropBtn.disabled = false; 
        }
    }

    async function handleTopUpTON() {
        selectors.topUpTonBtn.disabled = true; selectors.tonDepositStatus.textContent = "Создание запроса...";
        selectors.tonDepositLoader.style.display = 'block'; selectors.depositTonModal.style.display = 'flex';
        try {
            const res = await apiRequest('/api/initiate_ton_deposit', 'POST', {});
            currentDepositInfo = { address: res.recipient_address, comment: res.comment };
            selectors.tonDepositComment.value = res.comment;
            selectors.tonDepositStatus.textContent = "Готово к отправке.";
        } catch (e) { selectors.tonDepositStatus.textContent = "Ошибка. Попробуйте снова."; }
        finally { selectors.topUpTonBtn.disabled = false; selectors.tonDepositLoader.style.display = 'none'; }
    }

    async function verifyTONDeposit() {
        if (!currentDepositInfo.comment) { tg.showAlert("Ошибка: комментарий для проверки не найден."); return; }
        selectors.verifyTonDepositBtn.disabled = true; selectors.tonDepositStatus.textContent = "Проверяем транзакцию...";
        selectors.tonDepositLoader.style.display = 'block';
        try {
            const res = await apiRequest('/api/verify_ton_deposit', 'POST', { comment: currentDepositInfo.comment });
            if (res.status === 'success') {
                tg.showAlert(res.message); currentUser.balance = res.new_balance; updateBalanceUI();
                selectors.depositTonModal.style.display = 'none';
            } else { selectors.tonDepositStatus.textContent = res.message; }
        } catch (e) { selectors.tonDepositStatus.textContent = "Ошибка проверки. Попробуйте еще раз."; }
        finally { selectors.verifyTonDepositBtn.disabled = false; selectors.tonDepositLoader.style.display = 'none'; }
    }

    async function handleTopUpStars() {
        const amount = parseInt(selectors.depositAmountInput.value);
        if (isNaN(amount) || amount < 1) { tg.showAlert("Введите корректную сумму звезд."); return; }
        selectors.topUpStarsBtn.disabled = true;
        try {
            const res = await apiRequest('/api/create_stars_invoice', 'POST', { amount });
            tg.openInvoice(res.invoice_link, async (status) => {
                if (status === 'paid') {
                    tg.showAlert("Оплата прошла успешно! Баланс обновляется...");
                    const userData = await apiRequest('/api/user_data', 'POST', {});
                    currentUser = userData; updateBalanceUI();
                } else { tg.showAlert(`Статус оплаты: ${status}.`); }
            });
        } finally { selectors.topUpStarsBtn.disabled = false; }
    }

    // --- Event Listeners Setup ---
    selectors.navButtons.forEach(b => b.addEventListener('click', () => switchView(b.dataset.view)));
    selectors.dropButton.addEventListener('click', handleSingleDrop);
    window.addEventListener('resize', setupBoard);
    selectors.topUpTonBtn.addEventListener('click', handleTopUpTON);
    selectors.topUpStarsBtn.addEventListener('click', handleTopUpStars);
    selectors.topUpGiftsBtn.addEventListener('click', () => selectors.depositGiftsModal.style.display = 'flex');
    selectors.closeGiftsModalBtn.addEventListener('click', () => selectors.depositGiftsModal.style.display = 'none');
    selectors.verifyTonDepositBtn.addEventListener('click', verifyTONDeposit);
    selectors.closeTonDepositModalBtn.addEventListener('click', () => selectors.depositTonModal.style.display = 'none');
    selectors.claimFreeDropBtn.addEventListener('click', handleClaimFreeDrop);
    selectors.openWalletBtn.addEventListener('click', () => {
        if (!currentDepositInfo.address || !currentDepositInfo.comment) { tg.showAlert("Ошибка: данные для депозита не загружены."); return; }
        const tonUrl = `ton://transfer/${currentDepositInfo.address}?text=${encodeURIComponent(currentDepositInfo.comment)}`;
        tg.openTelegramLink(tonUrl);
    });
    selectors.betModeButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (isDropping) return;
            currentBetMode = button.dataset.bet;
            selectors.betModeButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            updateBoardSlots();
            setBetModeUI(button.dataset.bet);
        });
    });

    initializeApp();
});
</script>
</body>
</html>
