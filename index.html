<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Плинко</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0d0f1a; --surface-color: #1a1e3a; --surface-color-2: #252a4a;
            --border-color: rgba(255, 255, 255, 0.1); --text-color: #e2e8f0; --text-muted: #8a99b5;
            --button-primary-bg: linear-gradient(45deg, #a855f7, #6d28d9); --button-primary-text-color: #ffffff;
            --peg-color: #a3b8d9; --chip-color: #00f5ff; --highlight-primary: #a855f7; --highlight-secondary: #00f5ff;
            --button-secondary-bg: linear-gradient(45deg, #ec4899, #d946ef); --stepper-bg: #2c336b;
            --slot-high: #8e44ad; --slot-mid: #5a57c4; --slot-low: #3d4a99; --slot-zero: #2c336b; --nav-height: 70px; 
        }
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html { height: 100%; }
        body {
            font-family: 'Poppins', sans-serif; background-color: var(--bg-color); color: var(--text-color);
            display: flex; justify-content: center; min-height: 100%;
            padding: 33px 15px calc(var(--nav-height) + 30px);
            overflow-y: auto;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            background: linear-gradient(-45deg, #0d0f1a, #1a1e3a, #2c336b, #1a1e3a);
            background-size: 400% 400%;
            animation: gradient-animation 25s ease infinite;
        }
        #app-container { width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 15px; }
        .view { display: none; flex-direction: column; align-items: center; width: 100%; gap: 15px; }
        .view.active { display: flex; }
        header { width: 100%; text-align: center; margin-bottom: 5px; }
        header h1 {
            font-size: clamp(1.8rem, 7vw, 2.5rem); font-weight: 700; text-transform: uppercase; letter-spacing: 2px;
            color: white; background: linear-gradient(90deg, var(--highlight-secondary), var(--highlight-primary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(168, 85, 247, 0.3); margin: 0;
        }
        .game-board-area { width: 100%; }
        #plinko-board-container { position: relative; width: 100%; flex-shrink: 0; }
        @keyframes pulse-button {
            0%, 100% { transform: scale(1); box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
            50% { transform: scale(1.03); box-shadow: 0 8px 25px rgba(168, 85, 247, 0.3); }
        }
        @keyframes cosmic-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .main-button:not(:disabled) { animation: pulse-button 3s ease-in-out infinite; }
        @keyframes pulse-glow {
            0% { box-shadow: inset 0 0 25px rgba(0,0,0,0.7), 0 0 20px rgba(168, 85, 247, 0.2); }
            50% { box-shadow: inset 0 0 25px rgba(0,0,0,0.7), 0 0 35px rgba(0, 245, 255, 0.4); }
            100% { box-shadow: inset 0 0 25px rgba(0,0,0,0.7), 0 0 20px rgba(168, 85, 247, 0.2); }
        }
        #plinko-board {
            width: 100%; aspect-ratio: 1 / 1; position: relative; border-radius: 20px 20px 0 0;
            overflow: hidden; border: 1px solid var(--border-color); border-bottom: none;
            background: linear-gradient(-45deg, var(--surface-color), #2c336b, var(--surface-color-2), var(--highlight-primary));
            background-size: 300% 300%; animation: cosmic-flow 20s ease infinite, pulse-glow 5s ease-in-out infinite;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.7);
        }
        @keyframes scanline { 0% { transform: translateY(-100px); } 100% { transform: translateY(100px); } }
        #plinko-board::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
            background-image: repeating-linear-gradient(to right, transparent, transparent 49.5%, rgba(163, 184, 217, 0.1) 50%, transparent 50.5%, transparent 100%),
                              repeating-linear-gradient(to bottom, transparent, transparent 49.5%, rgba(163, 184, 217, 0.1) 50%, transparent 50.5%, transparent 100%);
            background-size: 30px 30px; mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
            animation: scanline 4s linear infinite alternate;
        }
        .peg { width: 8px; height: 8px; background-color: var(--peg-color); border-radius: 50%; position: absolute; box-shadow: 0 0 5px rgba(163, 184, 217, 0.3); transform: translate(-50%, -50%); z-index: 5;}
        .chip { position: absolute; background-color: var(--chip-color); border-radius: 50%; box-shadow: 0 0 8px var(--chip-color), 0 0 15px var(--chip-color); visibility: hidden; transform: translate(-50%, -50%); transition: width 0.3s, height 0.3s; will-change: transform, box-shadow; ; }
        #slots-container {
            display: flex;
            width: 100%;
            border-radius: 0 0 20px 20px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            border-top: none;
            /* New: Added a smooth gradient that reflects prize values (high on ends, low in middle) */
            background: linear-gradient(to right, var(--slot-high), var(--slot-mid), var(--slot-low), var(--slot-zero), var(--slot-low), var(--slot-mid), var(--slot-high));
        }
        
        .slot {
            flex-grow: 1;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 600;
            font-size: clamp(0.6rem, 2.5vw, 0.8rem);
            color: white;
            transition: all 0.3s ease;
            /* New: Made individual slot backgrounds transparent to reveal the container's gradient */
            background-color: transparent; 
        }
        @keyframes highlight-win { 0% { transform: scale(1); } 50% { transform: scale(1.1); filter: brightness(2) drop-shadow(0 0 15px var(--highlight-secondary)); } 100% { transform: scale(1); } }
        @keyframes gradient-animation { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
        .background-orb { position: fixed; border-radius: 50%; filter: blur(80px); opacity: 0.4; z-index: -1; }
        @keyframes float-orb { 0%, 100% { transform: translate(0, 0) scale(1); } 25% { transform: translate(40px, -60px) scale(1.1); } 50% { transform: translate(-30px, 50px) scale(0.9); } 75% { transform: translate(50px, 20px) scale(1.2); } }
        .slot.highlight { animation: highlight-win 0.6s ease-out; z-index: 10; }
        .panel { background-color: var(--surface-color); padding: 12px; border-radius: 20px; width: 100%; display: flex; flex-direction: column; gap: 10px; border: 1px solid var(--border-color); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        .balance-display { display: flex; justify-content: space-between; align-items: center; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 12px; padding: 8px 15px; }
        .balance-display label { font-size: 0.9rem; color: var(--text-muted); font-weight: 500; }
        .balance-display .value { background: none; border: none; outline: none; color: var(--text-color); font-size: 1.1rem; font-weight: 600; text-align: right; display: flex; align-items: center; }
        .main-button { width: 100%; padding: 18px 15px; font-weight: 700; font-size: 1.2rem; cursor: pointer; border: none; border-radius: 12px; color: var(--button-primary-text-color); text-shadow: 0 1px 3px rgba(0,0,0,0.3); box-shadow: 0 5px 15px rgba(0,0,0,0.2); transition: all 0.2s ease; display: flex; justify-content: center; align-items: center; background: var(--button-primary-bg); }
        .main-button:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0,0,0,0.3); filter: brightness(1.1); }
        .main-button:active:not(:disabled) { transform: translateY(-1px); }
        .main-button:disabled { background: #4a5568 !important; cursor: not-allowed; transform: none; box-shadow: none; filter: none; }
        #bottom-nav { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 500px; height: var(--nav-height); background-color: var(--surface-color); display: flex; justify-content: space-around; align-items: center; box-shadow: 0 -5px 30px rgba(0,0,0,0.3); border-top: 1px solid var(--border-color); z-index: 100; }
        .nav-button { background: none; border: none; color: var(--text-muted); font-family: 'Poppins', sans-serif; font-size: 0.7rem; font-weight: 600; cursor: pointer; padding: 10px; display: flex; flex-direction: column; align-items: center; gap: 4px; opacity: 0.7; transition: all 0.3s ease; position: relative; }
        .nav-button.active { color: var(--highlight-primary); opacity: 1; transform: translateY(-3px); }
        .nav-button.active::after { content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%); width: 6px; height: 6px; border-radius: 50%; background-color: var(--highlight-primary); }
        .nav-button svg { width: 24px; height: 24px; fill: currentColor; }
        .info-text { text-align: center; color: var(--text-muted); margin-bottom: 20px; line-height: 1.6; }
        #profile-avatar { width: 100px; height: 100px; border-radius: 50%; border: 3px solid var(--highlight-primary); margin: 0 auto 15px auto; display: flex; align-items: center; justify-content: center; font-size: 3rem; font-weight: 700; object-fit: cover; background-color: var(--surface-color-2); box-shadow: 0 0 20px rgba(168, 85, 247, 0.4); overflow: hidden; }
        #profile-name { text-align: center; font-size: 1.8rem; font-weight: 700; }
        #profile-username { text-align: center; color: var(--text-muted); font-size: 1rem; margin-bottom: 25px; }
        .modal { display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(10,10,20,0.7); backdrop-filter: blur(8px); align-items: center; justify-content: center; }
        .modal-content { background-color: var(--surface-color); padding: 20px; border-radius: 16px; width: 90%; max-width: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.4); border: 1px solid var(--border-color); }
        .modal-content h3 { margin-top: 0; }
        .modal-body { margin: 15px 0; } .modal-actions { display: flex; gap: 10px; } .modal-actions .button { flex-grow: 1; }
        #deposit-ton-modal input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); margin-bottom: 10px; text-align: center; }
        .loader { border: 4px solid #3a3f78; border-top: 4px solid var(--highlight-primary); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 15px auto; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #deposit-amount-input { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); text-align: center; font-size: 1.1rem; }
        
        #bet-mode-selector {
            display: flex; background-color: var(--bg-color); border-radius: 12px;
            padding: 4px; margin-bottom: 10px; border: 1px solid var(--border-color); gap: 5px;
        }
        .bet-mode-button {
            flex-grow: 1; padding: 10px 5px; border: none; background: none; border-radius: 9px;
            color: var(--text-muted); font-family: 'Poppins', sans-serif; font-weight: 600;
            font-size: 1rem; cursor: pointer; transition: all 0.3s ease;
        }
        .bet-mode-button.active {
            background: var(--button-primary-bg); color: white;
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.4);
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999; /* Make sure it's on top of everything */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(-45deg, #0d0f1a, #1a1e3a, #2c336b, #1a1e3a);
            background-size: 400% 400%;
            animation: gradient-animation 25s ease infinite;
            color: var(--text-color);
            transition: opacity 0.5s ease-out; /* For the smooth fade-out */
        }
        
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none; /* Prevents interaction during fade-out */
        }
        
        #lottie-animation {
            width: 150px;
            height: 150px;
            margin-bottom: 20px; /* Fine-tune spacing */
        }
        
        #loading-screen h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: linear-gradient(90deg, var(--highlight-secondary), var(--highlight-primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
        }
        
        #loading-screen p {
            margin-top: 15px;
            font-size: 1rem;
            color: var(--text-muted);
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="lottie-animation"></div>
        <h1>Plinko Gifts</h1>
        <p id="loading-text">Инициализация...</p>
    </div>
    <div class="background-orb" style="width: 400px; height: 400px; top: -150px; left: -150px; background-color: var(--highlight-primary); animation: float-orb 20s infinite ease-in-out;"></div>
    <div class="background-orb" style="width: 300px; height: 300px; bottom: -100px; right: -100px; background-color: var(--highlight-secondary); animation: float-orb 25s infinite ease-in-out reverse;"></div>
    <div id="app-container">
        <!-- Main Game View -->
        <div id="main-game-view" class="view active">
            <header><h1>Plinko</h1></header>
            <div class="game-board-area">
                <div id="plinko-board-container"><div id="plinko-board"></div></div>
                <div id="slots-container"></div>
            </div>
            <div class="panel">
                <div class="balance-display"><label>Баланс</label><div id="balance" class="value">0.00</div></div>
                <div id="bet-mode-selector">
                    <button class="bet-mode-button active" data-bet="200">200 ✨</button>
                    <button class="bet-mode-button" data-bet="1000">1000 ✨</button>
                    <button class="bet-mode-button" data-bet="4000">4000 ✨</button>
                </div>
                <button id="drop-button" class="main-button">Бросить</button>
            </div>
        </div>
        <!-- Free Try View -->
        <div id="free-try-view" class="view">
            <header><h1>Free Try</h1></header>
            <div class="panel">
                <p class="info-text">Получайте бесплатный бросок (ставка 2.5 Stars) каждые 24 часа!</p>
                <div id="timer-container" style="text-align:center; margin: 20px 0;">
                    <h2 id="timer" style="font-size: 2.5rem; color: var(--highlight-secondary); margin-bottom: 5px;">00:00:00</h2>
                    <span style="color: var(--text-muted);">До следующего броска</span>
                </div>
                <button id="claim-free-drop-btn" class="main-button">Забрать бросок</button>
            </div>
        </div>
        <!-- Profile View -->
        <div id="profile-view" class="view">
            <header><h1>Профиль</h1></header>
            <div class="panel">
                <div id="profile-avatar">?</div>
                <h2 id="profile-name">Пользователь</h2><p id="profile-username">@username</p>
                <div class="balance-display"><label>Баланс</label><div id="profile-balance" class="value">0.00</div></div>
                <h3 style="text-align:center; margin:15px 0 10px; font-size:1.1rem; color:var(--text-muted);">Пополнить баланс</h3>
                <input type="number" id="deposit-amount-input" placeholder="Сумма в Stars" style="margin-bottom: 15px;">
                
                <p style="text-align:center; margin:0 0 8px; font-size:0.9rem; color:var(--text-muted);">Пополнить с помощью:</p>
                <div style="display:flex; gap:10px;">
                    <!-- TON button is now hidden but kept in the code -->
                    <button id="topup-ton-btn" class="main-button" style="display: none;">Пополнить через TON</button>
                    
                    <!-- Stars and Gifts buttons are in one row, smaller, with new text -->
                    <button id="topup-stars-btn" class="main-button" style="background: var(--button-secondary-bg); flex-grow: 1; padding: 12px 5px; font-size: 1rem;">Звёзды</button>
                    <button id="topup-gifts-btn" class="main-button" style="background: var(--surface-color-2); flex-grow: 1; padding: 12px 5px; font-size: 1rem;">Подарки</button>
                </div>
                <div id="inventory-section" style="margin-top: 25px;">
                <h3 style="text-align:center; color:var(--text-muted);">Инвентарь Подарков</h3>
                <div id="inventory-container" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-top: 15px; max-height: 400px; overflow-y: auto; padding: 5px;">
                    <p id="inventory-placeholder" style="grid-column: 1 / -1; text-align: center; color: var(--text-muted);">Инвентарь пуст.</p>
                </div>
            </div>
            </div>
        </div>
    </div>
    <!-- Bottom Navigation -->
    <nav id="bottom-nav">
        <button class="nav-button" data-view="free-try-view"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20,6H18.18C18.09,5.69 18,5.35 18,5A3,3 0 0,0 15,2C13.95,2 13.04,2.54 12.5,3.35C11.96,2.54 11.05,2 10,2A3,3 0 0,0 7,5C7,5.35 7.09,5.69 7.18,6H4A2,2 0 0,0 2,8V19A2,2 0 0,0 4,21H20A2,2 0 0,0 22,19V8A2,2 0 0,0 20,6M15,4A1,1 0 0,1 16,5A1,1 0 0,1 15,6A1,1 0 0,1 14,5A1,1 0 0,1 15,4M10,4A1,1 0 0,1 11,5A1,1 0 0,1 10,6A1,1 0 0,1 9,5A1,1 0 0,1 10,4M20,19H4V8H20V19Z" fill="currentColor"/></svg><span>Free Try</span></button>
        <button class="nav-button active" data-view="main-game-view"><svg viewBox="0 0 24 24"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg><span>Игра</span></button>
        <button class="nav-button" data-view="profile-view"><svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg><span>Профиль</span></button>
    </nav>

    <!-- Modals -->
    <div id="deposit-ton-modal" class="modal">
        <div class="modal-content">
            <h3>Депозит через TON</h3>
            <div class="modal-body" style="text-align: center;">
                <p>Отправьте любую сумму TON. Ваш баланс будет пополнен в Stars по курсу <strong style="color: var(--highlight-secondary);">1 TON = 250 Stars</strong>.</p>
                <div style="margin: 15px 0;">
                    <strong style="color: var(--text-muted);">ВАШ УНИКАЛЬНЫЙ КОММЕНТАРИЙ:</strong><br>
                    <input type="text" id="ton-deposit-comment" readonly style="background-color: var(--bg-color); border-color: #ff9800; text-align: center; font-weight: bold; margin-top: 5px;">
                    <p style="color: #ff9800; font-size: 0.8rem; margin-top: 5px;"><strong>НЕ ИЗМЕНЯЙТЕ ЭТОТ КОММЕНТАРИЙ В КОШЕЛЬКЕ!</strong></p>
                </div>
                <div id="ton-deposit-loader" class="loader" style="display:none;"></div>
                <p id="ton-deposit-status"></p>
            </div>
            <div class="modal-actions" style="flex-direction: column; gap: 12px;">
                <button id="open-wallet-btn" class="main-button">Открыть кошелек</button>
                <button id="verify-ton-deposit-btn" class="main-button" style="background: var(--surface-color-2);">Я уже оплатил (Проверить)</button>
                <button id="close-ton-deposit-modal-btn" class="main-button" style="background: var(--stepper-bg);">Отмена</button>
            </div>
        </div>
    </div>
    <div id="deposit-gifts-modal" class="modal">
        <div class="modal-content">
            <h3>Депозит Подарками</h3>
            <div class="modal-body" style="text-align: center;">
                <p>Для пополнения подарками переведите ваш подарок @uberstard, в короткий период он вручную зачислит вам Stars на баланс.</p>
            </div>
            <div class="modal-actions" style="flex-direction: column;">
                <a href="https://t.me/uberstard" target="_blank" class="main-button" style="text-decoration: none;">Связаться с @uberstard</a>
                <button id="close-gifts-modal-btn" class="main-button" style="background: var(--stepper-bg);">Закрыть</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- START: Loading Screen Logic ---
    const loadingScreen = document.getElementById('loading-screen');
    const loadingText = document.getElementById('loading-text');

    // Initialize Lottie Animation using the provided URL
    lottie.loadAnimation({
        container: document.getElementById('lottie-animation'),
        renderer: 'svg',
        loop: true,
        autoplay: true,
        path: 'https://cdn.changes.tg/gifts/models/Jolly%20Chimp/lottie/Toddler.json'
    });

    const funnyPhrases = [
        "Загружаю подарочки...",
        "Чищу баги в коде...",
        "Корректирую ценники...",
        "Подкручиваю вам удачу...",
        "Проверяю подписки...",
        "Разгоняю пиксели...",
        "Настраиваю гравитацию шарика..."
    ];
    let phraseIndex = 0;
    const textInterval = setInterval(() => {
        phraseIndex = (phraseIndex + 1) % funnyPhrases.length;
        loadingText.textContent = funnyPhrases[phraseIndex];
    }, 2000); // Change text every 2 seconds

    function hideLoadingScreen() {
        clearInterval(textInterval);
        loadingText.textContent = "Готово!";
        
        // Wait a moment so the user sees "Готово!"
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
            // After the fade-out animation finishes, remove it from the display
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 500); // This duration must match the CSS transition duration
        }, 800); 
    }
    // --- END: Loading Screen Logic ---
    const tg = window.Telegram.WebApp;
    const API_BASE_URL = 'https://plinko-4vm7.onrender.com';
    const STAR_ICON_HTML = `<img src="https://github.com/Vasiliy-katsyka/plinko/blob/main/star.png?raw=true" alt="Stars" style="height: 1em; vertical-align: -0.1em; margin-left: 4px;">`;

    let currentUser = { id: null, balance: 0.00 };
    let isDropping = false;
    let activeChips = [];
    let chipIdCounter = 0;
    let boardSeed = null;
    let pegs = [];
    let BOARD_WIDTH, BOARD_HEIGHT, CHIP_RADIUS, PEG_RADIUS;
    let GRAVITY = 0.25, DAMPING = 0.55;
    let freeDropTimerInterval = null;
    let currentDepositInfo = { address: '', comment: '' };

    let currentBetMode = '200';
    const NUM_ROWS = 8;

    const selectors = {
        views: document.querySelectorAll('.view'),
        navButtons: document.querySelectorAll('.nav-button'),
        balance: document.getElementById('balance'),
        profileBalance: document.getElementById('profile-balance'),
        profileName: document.getElementById('profile-name'),
        profileUsername: document.getElementById('profile-username'),
        profileAvatar: document.getElementById('profile-avatar'),
        board: document.getElementById('plinko-board'),
        slotsContainer: document.getElementById('slots-container'),
        dropButton: document.getElementById('drop-button'),
        betModeButtons: document.querySelectorAll('.bet-mode-button'),
        topUpTonBtn: document.getElementById('topup-ton-btn'),
        topUpStarsBtn: document.getElementById('topup-stars-btn'),
        topUpGiftsBtn: document.getElementById('topup-gifts-btn'),
        depositAmountInput: document.getElementById('deposit-amount-input'),
        depositTonModal: document.getElementById('deposit-ton-modal'),
        tonDepositComment: document.getElementById('ton-deposit-comment'),
        verifyTonDepositBtn: document.getElementById('verify-ton-deposit-btn'),
        openWalletBtn: document.getElementById('open-wallet-btn'),
        closeTonDepositModalBtn: document.getElementById('close-ton-deposit-modal-btn'),
        tonDepositLoader: document.getElementById('ton-deposit-loader'),
        tonDepositStatus: document.getElementById('ton-deposit-status'),
        depositGiftsModal: document.getElementById('deposit-gifts-modal'),
        closeGiftsModalBtn: document.getElementById('close-gifts-modal-btn'),
        timerElement: document.getElementById('timer'),
        claimFreeDropBtn: document.getElementById('claim-free-drop-btn'),
        inventoryContainer: document.getElementById('inventory-container'),
        inventoryPlaceholder: document.getElementById('inventory-placeholder')
    };
    
    async function apiRequest(endpoint, method = 'POST', body = {}) {
        const config = {
            method,
            headers: { 'Content-Type': 'application/json', 'X-Telegram-Init-Data': tg.initData }
        };
        if (method.toUpperCase() !== 'GET') { config.body = JSON.stringify(body); }
        try {
            const response = await fetch(API_BASE_URL + endpoint, config);
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `HTTP error ${response.status}`);
            }
            return response.json();
        } catch (error) {
            tg.showAlert(error.message);
            throw error;
        }
    }

    async function initializeApp() {
        try {
            tg.ready(); 
            tg.expand();
            
            // This is where the app waits for the server
            const userData = await apiRequest('/api/user_data', 'POST', {});
            
            // Once data is loaded, we set everything up
            currentUser = userData;
            updateBalanceUI();
            updateProfileUI();
            setupBoard();
            loadInventory(); // Pre-load inventory
        } catch (error) {
            console.error("Failed to load user data:", error);
            tg.showAlert("Не удалось загрузить данные пользователя.");
        } finally {
            // This 'finally' block ensures the loading screen is hidden
            // whether the app loads successfully or fails.
            hideLoadingScreen();
        }
    }

    function updateBalanceUI() {
        const formattedBalance = `${currentUser.balance.toFixed(2)} ${STAR_ICON_HTML}`;
        selectors.balance.innerHTML = formattedBalance;
        selectors.profileBalance.innerHTML = formattedBalance;
    }

    function updateProfileUI() {
        selectors.profileName.textContent = currentUser.first_name || "User";
        selectors.profileUsername.textContent = currentUser.username ? `@${currentUser.username}` : `#${currentUser.id}`;
        selectors.profileAvatar.innerHTML = '';
        if (currentUser.photo_url) {
            const img = document.createElement('img');
            img.src = currentUser.photo_url;
            img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
            selectors.profileAvatar.appendChild(img);
            selectors.profileAvatar.style.cssText = 'padding: 0; font-size: 0;';
        } else {
            selectors.profileAvatar.textContent = (currentUser.first_name || "?").charAt(0);
            selectors.profileAvatar.style.cssText = '';
        }
    }

    function addGiftToInventoryUI(item) {
        // This item object comes directly from the server response ('won_item')
        // or from the inventory list.
        const selectors = {
            inventoryContainer: document.getElementById('inventory-container'),
            inventoryPlaceholder: document.getElementById('inventory-placeholder')
        };
        
        // Hide the 'Inventory is empty' placeholder
        if (selectors.inventoryPlaceholder) {
            selectors.inventoryPlaceholder.style.display = 'none';
        }
    
        const itemEl = document.createElement('div');
        itemEl.style.cssText = `background-color: var(--surface-color-2); border: 1px solid var(--border-color); border-radius: 12px; padding: 8px; text-align: center; display: flex; flex-direction: column; align-items: center; justify-content: space-between;`;
        
        // Use the inventory_id if available (from full load), or a temp ID for instant add.
        const itemId = item.inventory_id || `new-${Date.now()}`;
        
        itemEl.innerHTML = `<img src="${item.imageUrl}" style="width: 60px; height: 60px; object-fit: contain;"><span style="font-size: 0.7rem; color: var(--text-muted); margin-top: 5px;">${item.name}</span><button class="convert-btn main-button" data-id="${itemId}" data-value="${item.value}" style="width: 100%; font-size: 0.8rem; padding: 6px; margin-top: 8px; height: auto;">${Math.round(item.value)} ${STAR_ICON_HTML}</button>`;
        
        // Prepend to show the newest item first
        selectors.inventoryContainer.prepend(itemEl);
        
        // Re-attach the event listener to the new button
        const newButton = itemEl.querySelector('.convert-btn');
        if (newButton) {
            newButton.addEventListener('click', handleConvertGift);
        }
    }
    
    function switchView(viewId) {
        if (freeDropTimerInterval) { clearInterval(freeDropTimerInterval); freeDropTimerInterval = null; }
        selectors.views.forEach(v => v.classList.toggle('active', v.id === viewId));
        selectors.navButtons.forEach(b => b.classList.toggle('active', b.dataset.view === viewId));
        if (viewId === 'free-try-view') initFreeTryView();
    }
    
    async function updateBoardSlots() {
        try {
            // Generate a new random seed for this board layout
            boardSeed = Math.random().toString(36).substring(2); 
    
            // Send the current bet mode AND the new seed to the backend
            const response = await apiRequest('/api/get_board_slots', 'POST', { 
                betMode: currentBetMode,
                seed: boardSeed // <--- SEND THE SEED
            });
    
            selectors.slotsContainer.innerHTML = '';
            response.slots.forEach(slotData => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.innerHTML = `<img src="${slotData.imageUrl}" title="${slotData.name} (~${Math.round(slotData.value)} Stars)" style="height: 80%; object-fit: contain;">`;
                selectors.slotsContainer.appendChild(slot);
            });
        } catch (error) {
            console.error("Failed to update board slots:", error);
            tg.showAlert("Не удалось загрузить оформление для слотов.");
        }
    }

    async function handleSingleDrop() {
        const betAmount = parseInt(currentBetMode, 10);
        if (betAmount > currentUser.balance) { tg.showAlert("Недостаточно средств!"); return; }
        setControlsDisabled(true);
        currentUser.balance -= betAmount;
        updateBalanceUI();
        try {
            // Send the bet mode AND the EXISTING board seed
            const result = await apiRequest('/api/plinko_drop', 'POST', { 
                betMode: currentBetMode,
                seed: boardSeed // <--- SEND THE SAME SEED
            });
            animateSingleChip(result);
        } catch (error) {
            currentUser.balance += betAmount;
            updateBalanceUI();
            setControlsDisabled(false);
        }
    }

    function animateSingleChip(resultFromServer) {
        const chipId = chipIdCounter++;
        const chipEl = document.createElement('div');
        chipEl.className = 'chip';
        chipEl.style.width = `${CHIP_RADIUS * 2}px`;
        chipEl.style.height = `${CHIP_RADIUS * 2}px`;

        // --- NEW: Calculate targetX immediately ---
        let targetX;
        const finalSlotIndex = resultFromServer.final_slot_index;
        const targetSlot = document.querySelectorAll('.slot')[finalSlotIndex];
        if (targetSlot) {
            const slotRect = targetSlot.getBoundingClientRect();
            const boardRect = selectors.board.getBoundingClientRect();
            targetX = (slotRect.left - boardRect.left) + (slotRect.width / 2);
        } else {
            targetX = BOARD_WIDTH / 2; // Fallback to center if slot not found
        }
        // --- END NEW ---

        const newChip = {
            id: chipId, 
            x: BOARD_WIDTH / 2, 
            y: CHIP_RADIUS, 
            vx: (Math.random() - 0.5) * 4,
            vy: 0, 
            element: chipEl, 
            serverResult: resultFromServer,
            targetX: targetX // Add the pre-calculated targetX to the chip object
        };

        chipEl.style.transform = `translate(${newChip.x - CHIP_RADIUS}px, ${newChip.y - CHIP_RADIUS}px)`;
        chipEl.style.visibility = 'visible';
        selectors.board.appendChild(chipEl);
        activeChips.push(newChip);
        if (!isDropping) {
            isDropping = true;
            document.querySelectorAll('.slot.highlight').forEach(s => s.classList.remove('highlight'));
            requestAnimationFrame(updatePhysics);
        }
    }
    
    function setupBoard() {
        if (isDropping) return;
        BOARD_WIDTH = selectors.board.clientWidth;
        if (BOARD_WIDTH === 0) { setTimeout(setupBoard, 50); return; }
        BOARD_HEIGHT = selectors.board.clientHeight;
        const cols = NUM_ROWS + 2;
        PEG_RADIUS = BOARD_WIDTH / 150;
        CHIP_RADIUS = BOARD_WIDTH / 45;
        pegs = [];
        selectors.board.innerHTML = '';
        const hSpacing = BOARD_WIDTH / cols;
        const vSpacing = BOARD_HEIGHT / (NUM_ROWS + 1);
        for (let r = 0; r < NUM_ROWS; r++) {
            const numPegs = r % 2 === 0 ? cols - 1 : cols;
            const xOffset = r % 2 === 0 ? hSpacing : hSpacing / 2;
            for (let c = 0; c < numPegs; c++) {
                const x = xOffset + c * hSpacing;
                const y = vSpacing + r * vSpacing;
                pegs.push({ x, y });
                const pegEl = document.createElement('div');
                pegEl.className = 'peg';
                pegEl.style.cssText = `width:${PEG_RADIUS*2}px;height:${PEG_RADIUS*2}px;left:${x}px;top:${y}px;`;
                selectors.board.appendChild(pegEl);
            }
        }
        updateBoardSlots();
    }
    
    function updatePhysics() {
        if (activeChips.length === 0) {
            isDropping = false; setControlsDisabled(false);
            return;
        }

        // --- Tuned Constants for a more stable simulation ---
        const finalDescentStartY = BOARD_HEIGHT * 0.88;
        const maxHorizontalVelocity = 4; // Speed limit for X-axis
        const maxVerticalVelocity = 10;   // Speed limit for Y-axis
        const maxNudgeForce = 0.07;       // The maximum strength of the guiding push

        for (let i = activeChips.length - 1; i >= 0; i--) {
            const chip = activeChips[i];

            // 1. Apply Gravity
            chip.vy += GRAVITY;

            // 2. Main Physics Logic (Hybrid Approach)
            if (chip.y < finalDescentStartY) {
                // --- PHASE 1: Gentle Nudge (among the pegs) ---

                // Calculate the nudge force
                const nudgeForceFactor = 0.002;
                const nudgeStrength = (chip.y / BOARD_HEIGHT) * nudgeForceFactor;
                let forceX = (chip.targetX - chip.x) * nudgeStrength;
                const radiiSum = CHIP_RADIUS + PEG_RADIUS;
                const radiiSumSq = radiiSum * radiiSum; // This is (r1 + r2)^2

                // **CRITICAL FIX 1: Cap the nudge force**
                // This prevents the "shove" that causes clipping through pegs.
                forceX = Math.max(-maxNudgeForce, Math.min(maxNudgeForce, forceX));
                chip.vx += forceX;

                // Handle peg collisions
                pegs.forEach(peg => {
                    const dx = chip.x - peg.x;
                    const dy = chip.y - peg.y;
                
                    // 1. Check for collision using squared distances (much faster)
                    // This avoids calling Math.sqrt() for every peg on every frame.
                    const distanceSq = dx * dx + dy * dy;
                    
                    if (distanceSq < radiiSumSq) {
                        // 2. A collision occurred! Now we do the more complex math.
                        // We only calculate the expensive square root WHEN we absolutely need it.
                        const dist = Math.sqrt(distanceSq);
                
                        // Calculate the overlap to push the chip out of the peg
                        const overlap = radiiSum - dist;
                        const angle = Math.atan2(dy, dx);
                        
                        // Correct chip position immediately to prevent it from getting stuck inside the peg
                        chip.x += Math.cos(angle) * overlap;
                        chip.y += Math.sin(angle) * overlap;
                
                        // Calculate the collision normal (the direction of the impact)
                        const normalX = dx / dist;
                        const normalY = dy / dist;
                
                        // Use the dot product to find the velocity component along the normal
                        const dot = chip.vx * normalX + chip.vy * normalY;
                
                        // Reflect the chip's velocity vector off the peg's surface
                        // and apply damping to lose some energy (making it less bouncy)
                        chip.vx = (chip.vx - 2 * dot * normalX) * DAMPING;
                        chip.vy = (chip.vy - 2 * dot * normalY) * DAMPING;
                
                        // Add a tiny bit of random horizontal velocity to prevent paths from becoming too predictable
                        chip.vx += (Math.random() - 0.5) * 0.25;
                    }
                });

            } else {
                // --- PHASE 2: Smooth Landing (after clearing pegs) ---

                // Smoothly dampen horizontal velocity
                chip.vx *= 0.85;

                // **CRITICAL FIX 2: Stronger and smoother landing correction**
                // This ensures a perfect landing in the center of the slot.
                chip.x += (chip.targetX - chip.x) * 0.2;
            }
            
            // 3. Universal Updates
            
            // **CRITICAL FIX 3: Cap the overall velocity**
            // This is the safety net that guarantees no "tunneling" through pegs.
            chip.vx = Math.max(-maxHorizontalVelocity, Math.min(maxHorizontalVelocity, chip.vx));
            chip.vy = Math.max(-maxVerticalVelocity, Math.min(maxVerticalVelocity, chip.vy));

            // Update position based on final velocity for this frame
            chip.x += chip.vx;
            chip.y += chip.vy;

            // Handle wall collisions
            if (chip.x - CHIP_RADIUS < 0 || chip.x + CHIP_RADIUS > BOARD_WIDTH) {
                chip.vx *= -DAMPING;
                chip.x = Math.max(CHIP_RADIUS, Math.min(chip.x, BOARD_WIDTH - CHIP_RADIUS));
            }

            // Update element style
            chip.element.style.transform = `translate(${chip.x - CHIP_RADIUS}px, ${chip.y - CHIP_RADIUS}px)`;

            // Check if chip has fallen out
            if (chip.y - CHIP_RADIUS > BOARD_HEIGHT) {
                endDrop(chip);
                activeChips.splice(i, 1);
            }
        }
        requestAnimationFrame(updatePhysics);
    }
    
    // CORRECTED endDrop function
    function endDrop(chip) {
        chip.element.remove();
        const result = chip.serverResult;
        
        if (result.won_item) {
            tg.showAlert(`Вы выиграли: ${result.won_item.name}!`);
            if (result.won_item.value > 500) {
                 tg.HapticFeedback.notificationOccurred('success');
            }
            
            currentUser.balance = result.new_balance;
            updateBalanceUI();
    
            // New: Instantly add the won gift to the inventory UI
            addGiftToInventoryUI(result.won_item);
    
        }
    
        const targetSlot = document.querySelectorAll('.slot')[result.final_slot_index];
        if (targetSlot) {
            targetSlot.classList.add('highlight');
            setTimeout(() => targetSlot.classList.remove('highlight'), 600);
        }
    }
    
    function setControlsDisabled(disabled) {
        selectors.dropButton.disabled = disabled;
        selectors.betModeButtons.forEach(b => b.disabled = disabled);
    }
    
    function getSlotColor(m) {
        if (m >= 5) return 'var(--slot-high)'; // Based on multiplier relative to bet
        if (m >= 2) return 'var(--slot-mid)';
        if (m > 0) return 'var(--slot-low)';
        return 'var(--slot-zero)';
    }

    async function loadInventory() {
        const inventoryContainer = document.getElementById('inventory-container');
        const inventoryPlaceholder = document.getElementById('inventory-placeholder');
        inventoryContainer.innerHTML = ''; // Clear previous items
        inventoryPlaceholder.style.display = 'block';
        inventoryPlaceholder.textContent = 'Загрузка...';
        try {
            const data = await apiRequest('/api/get_inventory');
            if (data.inventory && data.inventory.length > 0) {
                inventoryPlaceholder.style.display = 'none';
                // Use the new helper function to build the UI
                data.inventory.forEach(item => addGiftToInventoryUI(item));
            } else {
                inventoryPlaceholder.textContent = 'Инвентарь пуст.';
            }
        } catch (e) { inventoryPlaceholder.textContent = 'Ошибка загрузки.'; }
    }
    
    async function handleConvertGift(event) {
        const button = event.currentTarget;
        const inventoryId = button.dataset.id;
        button.disabled = true; button.textContent = '...';
        try {
            const response = await apiRequest('/api/convert_gift', 'POST', { inventory_id: inventoryId });
            if (response.status === 'success') {
                tg.HapticFeedback.notificationOccurred('success');
                currentUser.balance = response.new_balance; updateBalanceUI();
                button.closest('div').remove();
                if (selectors.inventoryContainer.childElementCount <= 1) { // Only placeholder is left
                    selectors.inventoryPlaceholder.style.display = 'block';
                    selectors.inventoryPlaceholder.textContent = 'Инвентарь пуст.';
                }
            } else {
                tg.showAlert(response.error || 'Не удалось конвертировать подарок.');
                button.disabled = false; button.innerHTML = `${Math.round(button.dataset.value)} ${STAR_ICON_HTML}`;
            }
        } catch (e) { button.disabled = false; button.innerHTML = `${Math.round(button.dataset.value)} ${STAR_ICON_HTML}`; }
    }

    function updateFreeDropTimer() {
        const lastClaim = currentUser.last_free_drop_claim;
        if (!lastClaim) { selectors.timerElement.textContent = "Готово!"; selectors.claimFreeDropBtn.disabled = false; return; }
        const nextAvailableTime = new Date(lastClaim).getTime() + (24 * 60 * 60 * 1000);
        const timeLeft = nextAvailableTime - Date.now();
        if (timeLeft <= 0) {
            selectors.timerElement.textContent = "Готово!"; selectors.claimFreeDropBtn.disabled = false;
            if (freeDropTimerInterval) clearInterval(freeDropTimerInterval);
        } else {
            selectors.claimFreeDropBtn.disabled = true;
            const h = Math.floor(timeLeft / 36e5), m = Math.floor((timeLeft % 36e5) / 6e4), s = Math.floor((timeLeft % 6e4) / 1e3);
            selectors.timerElement.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        }
    }

    function initFreeTryView() { updateFreeDropTimer(); freeDropTimerInterval = setInterval(updateFreeDropTimer, 1000); }

    async function handleClaimFreeDrop() {
        selectors.claimFreeDropBtn.disabled = true;
        try {
            const result = await apiRequest('/api/claim_free_drop', 'POST', {});
            if (result.status === 'success') {
                // The alert was here. By removing it, the code will proceed immediately.
                currentUser.last_free_drop_claim = result.new_claim_time;
                switchView('main-game-view');
                // The balance doesn't actually change, but we call this for consistency.
                currentUser.balance = result.game_result.new_balance; 
                updateBalanceUI();
                // Start the animation with the result from the server.
                animateSingleChip(result.game_result);
            } else { 
                // If there's an error (e.g., claimed too early), show an alert and re-enable the button.
                tg.showAlert(result.message); 
                selectors.claimFreeDropBtn.disabled = false; 
            }
        } catch (e) { 
            selectors.claimFreeDropBtn.disabled = false; 
        }
    }

    async function handleTopUpTON() {
        selectors.topUpTonBtn.disabled = true; selectors.tonDepositStatus.textContent = "Создание запроса...";
        selectors.tonDepositLoader.style.display = 'block'; selectors.depositTonModal.style.display = 'flex';
        try {
            const res = await apiRequest('/api/initiate_ton_deposit', 'POST', {});
            currentDepositInfo = { address: res.recipient_address, comment: res.comment };
            selectors.tonDepositComment.value = res.comment;
            selectors.tonDepositStatus.textContent = "Готово к отправке.";
        } catch (e) { selectors.tonDepositStatus.textContent = "Ошибка. Попробуйте снова."; }
        finally { selectors.topUpTonBtn.disabled = false; selectors.tonDepositLoader.style.display = 'none'; }
    }

    async function verifyTONDeposit() {
        if (!currentDepositInfo.comment) { tg.showAlert("Ошибка: комментарий для проверки не найден."); return; }
        selectors.verifyTonDepositBtn.disabled = true; selectors.tonDepositStatus.textContent = "Проверяем транзакцию...";
        selectors.tonDepositLoader.style.display = 'block';
        try {
            const res = await apiRequest('/api/verify_ton_deposit', 'POST', { comment: currentDepositInfo.comment });
            if (res.status === 'success') {
                tg.showAlert(res.message); currentUser.balance = res.new_balance; updateBalanceUI();
                selectors.depositTonModal.style.display = 'none';
            } else { selectors.tonDepositStatus.textContent = res.message; }
        } catch (e) { selectors.tonDepositStatus.textContent = "Ошибка проверки. Попробуйте еще раз."; }
        finally { selectors.verifyTonDepositBtn.disabled = false; selectors.tonDepositLoader.style.display = 'none'; }
    }

    async function handleTopUpStars() {
        const amount = parseInt(selectors.depositAmountInput.value);
        if (isNaN(amount) || amount < 1) { tg.showAlert("Введите корректную сумму звезд."); return; }
        selectors.topUpStarsBtn.disabled = true;
        try {
            const res = await apiRequest('/api/create_stars_invoice', 'POST', { amount });
            tg.openInvoice(res.invoice_link, async (status) => {
                if (status === 'paid') {
                    tg.showAlert("Оплата прошла успешно! Баланс обновляется...");
                    const userData = await apiRequest('/api/user_data', 'POST', {});
                    currentUser = userData; updateBalanceUI();
                } else { tg.showAlert(`Статус оплаты: ${status}.`); }
            });
        } finally { selectors.topUpStarsBtn.disabled = false; }
    }

    // --- Event Listeners Setup ---
    selectors.navButtons.forEach(b => b.addEventListener('click', () => switchView(b.dataset.view)));
    selectors.dropButton.addEventListener('click', handleSingleDrop);
    window.addEventListener('resize', setupBoard);
    selectors.topUpTonBtn.addEventListener('click', handleTopUpTON);
    selectors.topUpStarsBtn.addEventListener('click', handleTopUpStars);
    selectors.topUpGiftsBtn.addEventListener('click', () => selectors.depositGiftsModal.style.display = 'flex');
    selectors.closeGiftsModalBtn.addEventListener('click', () => selectors.depositGiftsModal.style.display = 'none');
    selectors.verifyTonDepositBtn.addEventListener('click', verifyTONDeposit);
    selectors.closeTonDepositModalBtn.addEventListener('click', () => selectors.depositTonModal.style.display = 'none');
    selectors.claimFreeDropBtn.addEventListener('click', handleClaimFreeDrop);
    selectors.openWalletBtn.addEventListener('click', () => {
        if (!currentDepositInfo.address || !currentDepositInfo.comment) { tg.showAlert("Ошибка: данные для депозита не загружены."); return; }
        const tonUrl = `ton://transfer/${currentDepositInfo.address}?text=${encodeURIComponent(currentDepositInfo.comment)}`;
        tg.openTelegramLink(tonUrl);
    });
    selectors.betModeButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (isDropping) return;
            currentBetMode = button.dataset.bet;
            selectors.betModeButtons.forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            updateBoardSlots();
        });
    });

    initializeApp();
});
</script>
</body>
</html>
